props传值

```css
父组件	在调用子组件实例当中的位置,通过动态绑定自定义属性

在子组件中使用props接收

子组件中,不要直接改变,props接收的值,因为即使改变了,父组件一旦修改传递的值,子组件接收的值也会重新改变
```

$emit

```css
在子组件中通过调用自定义函数触发,函数内通过this.$emit('自定义事件名',传递的值)
父组件内引用注册并使用组件,对子组件动态绑定子组件的自定义事件=自定义函数,函数接收一个参数,参数就是传递的值
```

$refs

```css
父组件中导入注册并使用子组件,对子组件使用ref="自定义属性"
通过自定义函数触发,this.$refs.自定义属性;
获取子组件的实例,通过实例拿到子组件的值
```

兄弟传值

```css
子组件通过事件函数,函数内this.$emit('自定义事件名',传递的值),传递给父组件
父组件内导入注册并使用子组件,子组件动态绑定自定义事件名="自定义函数",函数接收传来的值,转存到父组件
父组件对另一个子组件动态绑定自定义属性="传递的值",子组件中使用props接收
```

$parent

```css
子组件中通过自定义函数触发,函数内this.parent获取当前组件的父组件(上级组件)的实例,
通过实例拿到父组件的值
```

$children

```css
父组件中通过自定义函数触发,函数内this.$children;以数组的形式,获取到子组件的实例,通过实例拿到子组件的值
```

$attrs

```css
在当前组件的父组件中,导入注册并使用当前组件,在当前组件的父组件中对当前组件使用动态绑定自定义属性进行传递;
在当前组件中导入注册并使用当前组件的子组件,在当前组件中对子组件动态绑定$attrs;
在当前组件的子组件中使用props接收,当前组件不能使用props接收,否则当前组件的子组件,接收不到当前组件接收过的值
```

$listeners

```css
当前组件的子组件的函数内使用this.$emit('自定义事件名',传递的值);
当前组件内导入注册并使用当前组件的子组件,对当前组件的子组件使用v-on=$listeners绑定监听事件;
当前组件的父组件内导入注册并使用当前组件,当前组件的父组件中对当前组件动态绑定自定义事件="自定义函数",自定义函数接收一个参数,参数就是传入的值
```

provide/inject

```css
当前组件的父组件使用和methods等同级的provide(){return{}},return一个对象,可以实现响应式数据;
当前组件的子组件中使用和methods同级的inject以数组的形式接收
```

slot

```css
slot分为具名插槽和匿名插槽;匿名插槽任何内容都可以插入;具名插槽拥有指定名称才可插入

slot传值
B组件中定义一个slot具名插槽
<slot name="example"></slot>

在A组件中导入注册并使用B组件,将要传入的内容,使用具名插槽名称slot=name,在B组件中使用props接收
<B text='传值'>
	<div slot="example"></div>
</B>
```

bus

```css
在main.js中全局挂载bus;	Vue.prototype.bus=new Vue();
A组件中使用this.bus.$emit('自定义事件',传递的值);
B组件中使用thsi.bus.$on('自定义事件',(val)=>{}),监听自定义事件,接收传入的值
注意：监听事件必须在传递值之前
```

mtt

```css

```

