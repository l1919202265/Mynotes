### vue2路由的安装、配置和使用

```js
//1、安装vue2的路由
npm install vue-router@3
    
//2、配置路由
	//src目录下新建文件夹router;router文件夹下新建index.js文件
	//index.js文件下配置
	import Vue from 'vue'
	//导入路由
	import VueRouter from 'vue-router'
	//导出路由
	Vue.use(VueRouter)
	//配置路由
	const router=new VueRouter({
    	routes:[]，
        mode:"hash" // "history" // "abstract" //定义路由模式
	})
	//导出路由
	export default router


//3、main.js中引用,注册路由文件
import router form '@/router/index.js'

new Vue({
  router,
  render: function (h) {
    return h(App)
  },
}).$mount('#app')
```

##### 路由传参

###### 第一种传参方式

```css
在路由配置文件中,为接收参数的路由配置传参参数,用冒号写在路径后 path: '/passed/:data'

在路由入口中,添加加传递参的路径及传递的值, <router-link to="/passed/333">Passed1</router-link>

在配置路由传参的组件中使用this.$route.params获取传递的值,参数显示在URL路径中


通过this.$route.params接收
路由配置为:path: '/passed/:data'
<router-link to="/passed/333">Passed1</router-link> |
<router-link to="/passed/999">Passed2</router-link> 
```

###### 第二种传参方式

```css
在路由配置文件中,设置路径 path: '/passed'

在路由入口中,添加加传递参的路径及传递的值, <router-link :to="{ path: '/passed', query: { data: 333 } }">Passed1</router-link>

在配置路由传参的组件中使用this.$route.query获取传递的值


第二种传值方式     
通过this.$route.query接收
路由配置为:path: '/passed'
<router-link :to="{ path: '/passed', query: { data: 333 } }">Passed1</router-link> |
<router-link :to="{ path: '/passed', query: { data: 999 } }">Passed2</router-link> 
```

###### 第三种传参方式

```css
在路由配置文件中,为接收参数的路由配置命名 name: 'passed'

在路由入口中,添加加传递参的路径及传递的值, <router-link :to="{ name: 'passed', params: { data: 333 } }">Passed1</router-link>

在配置路由传参的组件中使用this.$route.params和this.$route.query获取传递的值

第三种传参方式     name命名式路由
query和params都可以接收
路由配置为name: 'passed'
<router-link :to="{ name: 'passed', params: { data: 333 } }">Passed1</router-link> |
<router-link :to="{ name: 'passed', query: { data: 999 } }">Passed2</router-link> 
```

###### 第四种传参方式 编程式路由传参

```js
定义一个函数,通过函数触发编程路由

            // 第一种方法   仅跳转
            this.$router.push('/passed')

            // 第二种方法    跳转并传值      注意:使用path时params用于在路由配置中声明参数，
            //而query用于在URL中传递查询参数。所以，在这个场景中，我们应该使用query来传递参数，而不是params
            this.$router.push({
                path: '/passed',
                query: {
                    data: 333
                }
            })
            this.$router.push({
                name: 'passed',
                query: {
                    data: 333
                }
            })
            this.$router.push({
                name: 'passed',
                params: {
                    data: 999
                }
            })

            // 第三种方法   替换跳转并传值      注意:使用path时params用于在路由配置中声明参数，
            // 而query用于在URL中传递查询参数。所以，在这个场景中，我们应该使用query来传递参数，而不是params
            this.$router.replace({
                path: '/passed',
                query: {
                    data: 333
                }
            })
		   //使用query参数会显示在URL路径中
            this.$router.replace({
                name: 'passed',
                query: {
                    data: 333
                }
            })
		   //使用params参数不会显示在URL路径中
            this.$router.replace({
                name: 'passed',
                params: {
                    data: 333
                }
            })

            // 第四种方法
            // 回退到上一级页面,如果超出历史记录则无状态
            this.$router.go(-1)
```

在Vue Router中，通过`query`属性传递的参数会作为查询参数附加在URL中，并不会直接显示在路由链接的文本中。 `router-link`组件的文本内容是用户可见的链接文本，而不是URL参数的显示。

### 全局路由守卫

##### 全局路由前置守卫

```js
//beforeEach内接收一个函数作为参数,作为参数的函数接收三个参数:to,from,next;
//to:去哪
//from:从哪来
//next:放行
router.beforeEach((to,from,next)=>{
    console.log('全局路由前置守卫');
    next();
})
```

##### 全局路由后置守卫

```js
//afterEach内接收一个函数作为参数,作为参数的函数接收两个个参数:to,from;
//to:去哪
//from:从哪来
router.afterEach((to,from)=>{
    console.log('全局路由后置守卫');
})

//可以在全局后置守卫中设置标签选项卡标题
//document.title=to.meta.title;获取每个路由的meta属性的设置的title标题
```

##### 路由独享守卫

```js
//在路由配置中进行设置
//进入组件前
beforeEnter(to,from,next){
    
}
```

##### 组件内守卫

```js
//在组件中配置
//进入组件前
//beforeRouteEnter内接收三个参数:to,from,next;
beforeRouteEnter(to,from,next){
     
 }

//组件更新前
//beforeRouterUpdate内接收三个参数:to,from,next;
beforeRouterUpdate(to,from,next){
    
}

//组价离开前
//beforeRouterLeave内接收三个参数:to,from,next;
beforeRouterLeave(to,from,next){
    
}
```

Error

```css
Redirect when going from "*" to "**" vis a navigation guard

解决方案:使用编程式导航跳转时，每次使用，后面都跟上.catch方法，捕获错误信息
this.$router.push('/buy').catch(err=>(''))
```



## 谈一谈路由守卫：

>  路由守卫：
>
>  ​        就是对路由进行一些保护，比如登陆权限的验证
>
>  ​        在路由的跳转前、后 进行校验
>
>  
>
>  ​        分为： 全局路由守卫  路由独享守卫  组件内的路由守卫
>
>  ​        全局分为两种： 前置  后置
>
>  ​           前置： beforeEach(to,from,next)
>
>  ​           后置： affterEach(to,from)
>
>  
>
>  ​        路由独享守卫，写在当前路由的配置项下面，beforeEnter(to,from,next)
>
>  
>
>  ​        组件内路由守卫：
>
>  ​                      beforeRouteEnter(to,from,next)  通过路由进入当前组件后 
>
>  ​                      beforeRouteUpdate(to,from,next)  通过路由传值的时候触发   to 拿 params query 参数
>
>  ​                      beforeRouteLeave(to,from,next)   通过路由离开当前组件后

#### 路由的模式

+ hash路由在地址栏URL上有#,而history优点是URL看起来更加干净，没有哈希值。
+ 进行刷新操作时,hash路由不会发送后台,而history路由一般就404报错了(刷新是网络请求,页面没有配置对应接口)【hash模式，#后面的数据，不会请求发送给后台，historyhi发送】
+ hash路由支持版本低的浏览器，而historyshiH5新增的API
+ hash的特点在于它虽然出现在了URL路径中，但是不包括在http请求中，所以对于后端没有一点影响，所以改变hash不会重新加载页面，所以这也是单页面应用的必备
+ history运用了浏览器的历史记录栈，之前有back，forward，go方法，之后在H5中新增了，pushState（）和replaceState（）方法（需要特定浏览器的支持），他们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器 不会马上向后端发送请求

