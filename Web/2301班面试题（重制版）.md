####  1.computed 和watch 的区别

```css
1、computed是计算属性一对多监听，watch是事件监听一对一监听，computed默认是深度监听，watch默认是浅度监听（如果需要深度监听，需要设置deep:true）

2、computed调用了才会监听到数据的变化重新计算；watch无需调用，只要监听到的数据发生变化就会立即执行监听，如果需要页面加载完成就立即监听，需要设置immediate:true
```



#### 2.vue2双向数据绑定原理

```css
1、Vue2的双向数据绑定原理，基于订阅者和发布者模式的，订阅者使用的是data数据中的dom节点，发布者使用的是vue

1、当创建vue实例的时候，会自动把订阅者添加到发布者存储订阅者的数组中，通过	Object.defineProperty对vue中的data数据进行数据监听，数据拦截。

3、当vue中的data数据发生变化的时候，发布者会通过notify方法，找到订阅者中的回调函数，把更新后的数据传递给订阅者，订阅者拿到更新后的数据后，展示在页面上

Object.defineProperty的缺陷:

Object.defineProperty无法低耗费的监听到数组下标的变化，导致通过数组下标添加元素，不能实时响应

Object.defineProperty只能拦截对象的属性，从而需要对每个对象，每个属性进行遍历。如果属性值是对象，还需要深度遍历。Proxy可以拦截整个对象，并返回一个新的对象

Proxy不仅可以代理对象，还可以代理数组，还可以代理动态增加的属性
```



#### 3.有没有封装过axios请求

```css
1.引入axios

import axios from 'axios'

2.把这个axios这个包挂载在vue的实例上 这样每一个组件都可以使用 从而发起axios请求

Vue.prototype.$http = axios

3.给axios设置根路径   配置请求的根路径
axios.defaults.baseURL ='http://127.0.0.1:8888/api/private/v1/'

Vue.prototype.$http = axios;
axios.defaults.baseURL = 'http://www.chenfuguo.cn:8899/api/private/v1'
Vue.use(VueAxios, axios)

```



#### 4.vue2和vue3的区别

```css
1、vue2和vue3双向数据绑定原理不同，vue2使用的Object.definePropetry（）,而Vue3使用了Proxy代理对象。
   Proxy相比Object.defineProperty具有更强大和灵活的功能，能够捕获更多的操作并提供更好的性能。

2、vue2是选项式API，vue3是组合式API

3、vue3对ts的支持更加友好，vue3的底层本身就是用ts写的。

4、vue2是把数据放在data里中，方法放在methods中， vue3在语法糖中，可以把数据，方法都放在setup中

5、生命周期不同，vue3在使用选项式api时，生命周期函数和vue2对比：

   把vue2的beforeDestroy和destroyed 变为了beforeUnmount（卸载前），unmounted（卸载后）

	 vue3在使用组合式api的写法时，生命周期分别是：
	 
	 onBeforeMount：在组件挂载到DOM之前调用。

   onMounted：在组件挂载到DOM之后调用。

   onBeforeUpdate：在虚拟DOM重新渲染之前调用，在组件更新之前执行。

   onUpdated：在虚拟DOM重新渲染之后调用，在组件更新之后执行。

   onBeforeUnmount：在组件卸载之前调用。

   onUnmounted：在组件卸载之后调用。
	
6、vue2中v-for比v-if优先级高  vue3中 v-if比v-for优先级高

7、vue2在处理引用数据类型的时候比如数组，或者给对象中添加一个当前对象不具备的属性值时，会出现更改的时候不会响应在页面上
   这个时候就需要用$set进行解决。而在vue3的时候就不会出现这个情况
   
8、keepAlive的使用发生了变化

	 vue2中的使用方法：
	  <keep-alive>
       <router-view v-if="$route.meta.keepAlive"></router-view>
    </keep-alive>
    
    <router-view v-if="!$route.meta.keepAlive"></router-view>
    
   vue3中的用法：
    
     <router-view v-slot="{ Component }">
         <keep-alive>
             <component :is="Component" v-if="$route.meta.keepAlive"></component>
         </keep-alive>

         <component :is="Component" v-if="!$route.meta.keepAlive"></component>
     </router-view>



9、watch 监听不同 
	 vue3中使用watch，接受三个参数 ，分别是监听对象，执行的回调函数，配置是否立即监听
	 
	 import { watch } from 'vue'
   watch(source, callback, options)
	
	 在vue2中，数据可以正常进行监听
	 但是在vue3中，watch监听reactive定义的响应式数据全部属性时：
   1：无法监听到老的数据，只能获取修改后的最新数据
   2：强制开启了深度监听，deep:false 无效
   
   vue3中，使用watch监听ractive包裹的响应式数据某个属性内部的属性变化

   即：我们监听的属性值是一个对象，如果当前对象内部的属性发生变化时
   此时，我们需要开启deep,但此时oldVal无法正常获取
    
	 
10、vue2中，data中存储的数据都是相应式数据，vue3中，响应式数据需要使用ref或者reactive函数包裹，普通数据只有使用ref包裹后，才会变成响应式局，引用数据类型，如对象和数组，需要使用reactive函数包裹后，才会变成响应式数据

11、路由的引入和路由模式也不同了 
	vue2中，安装路由后，通过导入 vue-router，通过new VueRouter创建路由器，路由的模式通过mode配置
	vue3中，通过createRouter函数创建路由，路由模式通过配置history，引入路由模式函数
	       vue2中的history模式，vue3中 createWebHistory（）
	       vue2中的hash模式，vue3中createWebHashHistory（）
	
	vue2写法：
	import VueRouter from 'vue-router'
  Vue.use(VueRouter)
  const router = new VueRouter({
        routes:[]  //定义路由配置
        mode:"hash" | "history" | "abstract" //定义路由模式
        //hash: 使用 URL hash 值来作路由。支持所有浏览器
        //history: 依赖 HTML5 History API 和服务器配置
        //abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。
        ...
   });
   
   vue3写法：
   import { createRouter, createWebHashHistory, RouteRecordRaw } from 'vue-router'

   const reouter = createRouter({
 	 		history: createWebHashHistory(),
  		routes: [
    		{
      			path: '/home',
      			name: 'home',
      			component: () => import('../components/Home.vue')
   		 }
  		]
		})

	export default reouter
	
12、this的问题
    
    在Vue.js 2中，通过在Vue组件的方法中使用this关键字来访问组件实例。这意味着在Vue组件内部，可以通过this访问Vue组件的属性、方法     	和生命周期钩子函数。
    Vue.js 3对this的处理方式进行了一些更改。在Vue.js 3中，默认情况下，组件内部的方法不再绑定到组件实例上。这意味着在Vue组件的方法中使用this将不再访问Vue组件的属性、方法和生命周期钩子函数。
    vue3中，如果想要使用this，需要通过 getCurrentInstance 方法才能得到this
    
13、ref的使用
		vue2中，可以在当前组件中，通过this.$refs.ref的值 获取当前组件内一切的元素 或者绑定了ref属性的子组件。
		同时，可以通过this.$refs获取子组件的实例，来获取子组件上具备的一切属性和方法
		
		在vue3中，通过ref获取子组件实例的时候，只能获取到子组件通过expose暴露的属性或方法。父组件通过ref 无法获取到 非 defineExpose 包裹的数据
		

14、Vue3 中没有了 EventBus 跨组件通信，通过mitt.js替代Bus传值
    
    使用步骤：

		1、安装mitt
       npm install mitt

		2、main.ts中引入mitt

   		 main.ts文件下：
   		 
   		 import mitt from 'mitt' // 导入mitt
			 const app = createApp(App)
			 app.config.globalProperties.$mitt = mitt() // mitt在vue3中挂载到全局
			 
		
		3、通过mitt传递数据：
		
		// 通过mitt 暴露info  传值
 				 proxy.$mitt.emit('自定义事件名', 'mitt传递出来的值')
 				 
 		// 监听mitt传递数据
 		 proxy.$mitt.on('mitt自定义事件名', val => {
        console.log(val)
     })
     
     实例：
		<template>
      <div class="sonBox">
            <h5>子组件</h5>
           <button @click="send">通过mitt传值</button>
       </div>
    </template>

     <script lang="ts" setup>
					import { ref, reactive, getCurrentInstance } from 'vue'
					let { proxy } = getCurrentInstance()
					
			const send = () => {
 				 // 通过mitt 暴露info  传值
 				 proxy.$mitt.emit('info', 'mitt传递出来的值')
			}
		</script>

		<style lang="less" scoped>
				.sonBox {
  					width: 80%;
 						margin: auto;
 					 	padding: 30px;
  					background-color: white;
  					color: rgb(96, 95, 95);
					}
		</style>
		
		
		//接收值：
		<template>
  			<div class="fatherBox">
    			<h4>父组件</h4>
    			<Son></Son>
  			</div>
		</template>

		<script lang="ts" setup>
		import { ref, reactive, getCurrentInstance, onMounted } from 'vue'
		import Son from './Son.vue'
		let { proxy } = getCurrentInstance()
		onMounted(() => {
		//监听mitt传递的数据
  		proxy.$mitt.on('info', val => {
    	console.log(val)
 		 })
		})
		</script>   
   
```



#### 5.vue2的生命周期都有那些

| **生命周期函数**            | **含义**                                                     |
| --------------------------- | ------------------------------------------------------------ |
| **beforeCreate（创建前）**  | **组件实例刚被创建，只有一些声明周期函数和默认事件，data和methods中的数据还没有初始化【加一些loading事件】** |
| **created（创建后）**       | **组件实例刚创建完成，属性已经绑定，当时DOM还未生成，$el属性还不存在【结束loading事件，还做一些初始化，实现函数自执行等】** |
| **beforeMount(挂载前)**     | **模板编译、挂载之前**                                       |
| **mounted（挂载后）**       | **模板编译、挂载之后【发起后端请求，取回数据接收页面之间传递的参数子组件向父组件传递参数】** |
| **beforeUpdate（更新前）**  | **组件更新之前**                                             |
| **updated（更新后）**       | **组件更新之后**                                             |
| **beforeDestroy（销毁前）** | **组件销毁前调用**                                           |
| **destroyed（销毁后）**     | **组件销毁后调用**                                           |

```
beforeCreate（创建前）:组件实例刚被创建，只有一些生命周期函数和默认事件，data和methods中的数据还没有初始化

created（创建后）:组件实例刚创建完成，属性已经绑定，此时是可以访问到date中的数据，method中的方法，但是依然无法访问vue实例挂载的位置

beforeMount(挂载前)：此时已经生成了虚拟dom，虚拟dom已经放在内存中，但是并没有展示到界面中，$el可以获取到vue实例挂载的位置

mounted（挂载后）：虚拟dom已经展示在页面上，$el获取到的就是页面中的真实dom//一般在此时完成axios请求，获取后台数据，展示在页面上

beforeUpdate（更新前）：数据变化前，当数据发生变化时，才会执行该函数，此时拿到的数据是最新的，但是还没有向页面展示,页面数据还是老的

updated（更新后）：此时已经把更新的数据展示在页面上，此时的数据是最新数据，页面展示的数据也是最新数据

beforeDestroy（销毁前）：依然可以获取实例上的数据，只是清除自定义事件，杀死实例后，vue开发者工具Devtools已经监听不到数据了，数据还可以修改但是页面已经不再更新了

destroyed（销毁后）:vue实例的所有东西都会解绑，所有时间监听器都会被移除，所有的子实例也会被销毁

keep-alive提供了两个生命周期函数activated,deactivated;由keep-alive包裹的路由出口会被缓存，未被包裹的，切换到其他组件时会被销毁
```

注:在keep-alive 的时候 会增加两个生命周期:actived  deactivated



```
vue3生命周期做出了一些改动

前面的是vue2的后面是vue3

beforeCreate  -> setup() 开始创建组件之前，创建的是data和method

created       -> setup()

beforeMount   -> onBeforeMount 组件挂载到节点上之前执行的函数。

mounted       -> onMounted 组件挂载完成后执行的函数

beforeUpdate  -> onBeforeUpdate 组件更新之前执行的函数。

updated       -> onUpdated 组件更新完成之后执行的函数。

beforeDestroy -> onBeforeUnmount 组件挂载到节点上之前执行的函数。

destroyed     -> onUnmounted 组件卸载之前执行的函数。

```



#### 6.深拷贝和浅拷贝的区别，如何实现一个深拷贝和浅拷贝

```
浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即
发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。

实现浅拷贝的方法：
1.object.assign()
2.扩展运算符
3.array.prototype.concat()
4.array.prototype.slice()
5.解构赋值


深拷贝的实现方法：
1.使用JSON.parse(JSON.stringify())
2.或者使用递归进行深拷贝
3.for in 
4.structurdClone
5.lodash：_.cloneDeep
6.jquery  $extend


JSON.parses和JSON.stringify的缺点：
1.拷贝对像的中有undefined，拷贝之后属性会丢失
2.拷贝对象为正则表达式的时候，拷贝之后正则表达式会变成object
```

![img](https://img-blog.csdnimg.cn/2021012914233287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk4OTE4OA==,size_16,color_FFFFFF,t_70)

#### 7.vue的组件通信

```
1、父传子（props)：在子组件中使用props期待接收的值
				在父组件中引入子组件注册使用 在父组件中就可以直接进行动态数据绑定自定义属性，这样就可以完成一个父子之间的传值
				
2、子传父($emit)：在子组件中使用事件触发，使用$emit（）传递两个参数，第一个参数是自定义的事件名，第二个参数是传递的值，然后在父组件				中引入注册使用子组件，使用$emit()的自定义事件定义一个函数，函数内传递一个参数，这个参数就是传递给父组件的值

3、兄弟之间的传值:先传递给父组件，再通过父组件传递给子组件

4、$refs传值实现父子组件的通信"ref"这个属性用在子组件上，它的作用就指向了子组件的实例，可以通过实例来访问子组件的数据和方法

5、依赖注入（provide / inject）父子传值，也可以是祖孙组件传值

6、$parent :使用$parent可以让子组件访问父组件的实例（访问的是上一级父组件的属性和方法）

7、$children:使用 $children 可以让组件访问子组件的实例，但是， $children 并不能保证顺序，并且访问的数据也不是响应式的。

8、$attrs:在当前组件的父组件上,引入注册并使用当前组件,在当前组件的父组件中对当前组件使用动态绑定自定义属性进行传递,在当前组件中引入注册并使用当前组件的子组件,在当前组件中对子组件动态绑定$attrs,在当前组件的子组件中使用props接收,当前组件不能使用props接收,否则当前组件子组件接收不到当前组件接收过的值

$listeners:

bus

mtt

$attrs/$listeners区别：
	1、$attrs和$listeners都是vue实例对象的一个属性			$attrs获取到的内容，是当前组件的父组件正向传递的值，当前组件没有通过props接收的全部属性和值
		$listeners获取到的，是当前组件的父组件对当前组件进行监听的所有自定义事件
	2、在应用的时候，
		$attrs是用来进行上级向下级的跨组件传值，比如爷孙传值
		$listeners 使用来进行下级向上级进行跨组件传值，比如孙子向爷爷组件传值
	3、使用方面：
		以 a,b,c三个组件为例(a爷爷，b父亲，c孙子)，$attrs的使用，是在中间的b组件调用c组件的位置使用，v-bind='$attrs'，c组件使用priops接收a组件传递的属性
		以 a,b,c三个组件为例，$listeners的使用，c组件进行this.$emit（）进行传值，a在调用b组件的位置，监听c组件的自定事件，b组件在调用c组件的位置，<c v-on='$listeners'></c>
bus传值：

	1、在main.js中全局挂载bus：（Vue.prototype.bus = new Vue();）
	2、在需要传递数据的组件中使用bus触发自定义事件（this.bus.$emit('自定义事件名'，要传递的值)）
	3、在需要结收的组件的mounted钩子函数中，使用bus监听通bus的自定义事件，this.bus.$on('自定义事件名'，（）=>{v}) 

vuex
slot
路由传参
.sync
pinia
```



#### 8.es6的新增特性

```
1、let、const
	let:
	(1)let声明的变量，不存在变量提升的问题
	(2)let不允许在相同作用域内声明同名变量，不允许重复声明变量
		暂时性死区：1、在声明前调用当前变量，就产生了暂时性死区；
		2、在声明未结束就调用也会形成暂时性死区)
	const:
	(1)常量声明后之不能被更改
	(2)常量声明必须赋值
	(3)作用域同let一样，距离最近的大括号
	
2、解构赋值

3、模板字符串

4、扩展运算符

5、set、map
	set 可以进行数组的去重 set本身是一个构造函数 
	map 是用来储存对象的 map的方法和遍历方法和set是一样的
	
6、promise

Proxy代理拦截
	
7、class 
	1、在class类种有一个constructor()用来传递参数
	2、class类本质就是一个构造函数，是可以创建实例对象 class类中有get set两个函数，get是取值函数，set是存值函数  在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。
	3、Class 可以通过结合extends关键字和 super()方法实现继承module模块 使用 export进行暴露  使用import接收
	
8、箭头函数
	箭头函数与普通函数的区别：
		(1)写法不同：箭头函数使用箭头定义，普通函数中没有。
				  普通函数使用funchtio定义函数，箭头函数，省略了funchtion，在函数的参数后面使用箭头声明
				  
		(2)箭头函数不能用于构造函数：普通函数可以用于构造函数，以此创建对象实例。构造函数的this 指向到 当前构造函数的实例对象   this是可以改变的。箭头函数的this无法改变，箭头函数的this无法指向当前函数的实例对象，继承他声明所在上级函数的this,所以 他不能作为构造函数
		
		(3)箭头函数中this的指向不同：箭头函数自身没有this，它的this是父级普通函数的this。如果箭头函数式没有父级函数，则this指向window。在普通函数中，this总是指向调用它的对象或者window，如果用作构造函数，它指向创建的对象实例。
		
		(4)箭头函数不具有arguments对象：每一个普通函数调用后都具有一个arguments对象，用来存储实际传递的所有参数。但是箭头函数并没有此对象。如果箭头函数想要获取全部的参数，需要使用reset参数获取
		
		(5)箭头函数不具有prototype原型对象。
		
		(6)箭头函数不具有super。
```





#### 9.promise是什么，解决了什么，都有那些状态

```
1、promise  是一种异步编程解决方案，解决了回调地狱
	promise有三种状态:pending（进行中）变为fulfilled(成功)或rejected(失败)，状态一经修改不允许改变。
2、promise是一个构造函数，用来声明promise对象，promise构造函数接收一个函数作为参数，作为函数的参数内接收两个参数分别是resolve,reject。
3、promise四个常用方法：
		(1)then()方法：用于处理Promise对象的成功状态，接受一个回调函数作为参数
		(2)catch()方法:用于处理Promise对象的失败状态，
		(3)all()方法：同时提交多个promise操作，返回的结果是一个数组
		(4)finally()：无论Promise对象状态最终是成功（Fulfilled）还是失败（Rejected）,都会执行
	总结：一般使用async和await修饰符简化promise操作，async修饰函数，await接收结果，await必须在async修饰的函数中使用
```



#### 10.get和post的传值方式

```css
1.Post传输数据时，不会在URL中显示出来，而Get方法会在URL中显示。Post的请求式放在请求体中
2.Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度的限制,只能传递大约1024字节.
3.Post将数据传送到服务器端,Get从服务器端取得数据.而Get之所以也能传送数据,只是用来设计告诉服务器,
4.get可以缓存 post不可以缓存
5.get 传输的数据类型 AscII post 可以是任意类型还可以接收二进制
```



#### 11.讲一下vuex

```js
安装：npm install vuex --save

	vuex是vue程序中的一个状态管理模式，他可以把所有组件需要共享的数据，统一进行管理，如果想要修改的时候，需要按照vuex中定义好的规则进行修改
	vuex的实例中，有5个方法，分别是 state，mutations,actions,getters,modules。

state存储状态，即存储项目中需要共享的数据。
	在外部组件使用状态的时候，使用this.$store.state.属性名

mutations中存储同步对state状态修改的方法。
	在外部触发修改的时候，使用 this.$store.commit('方法名'，传递的参数)

actions中存储异步对state状态修改的方法，actions中的方法，需要依赖于mutations中的方法。
	外部调用： this.$store.dispatch('方法名'，参数)

getters 相当于计算属性，可以在不修改state的情况下，根据需求，筛选出state中对应的数据。
	  外部调用： this.$store.getter.getter内的属性名

modules 把store仓库进行模块化，在使用的时候，属性 对应 导入的store模块
	vuex自带了四个辅助函数，分别是mapState , mapMutations, mapActions, mapGetters
计算属性：mapState,mapGetter
mothods中：mapMutations,mapActions
```



#### 12.弹性布局和传统布局的区别

```
传统布局，基于盒模型，依赖 display属性 、position属性 、float属性

Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 
任何一个容器都可以指定为 Flex 布局。
设为 Flex 布局以后，子元素的float、clear（克里r） 和 vertical-align（沃梯口-饿蓝印） 属性将失效
```



#### 13.map和forEach、find、findIndex、filter、reduce的区别

```
forEach() 方法不会返回执行结果，而是undefined。

也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。

forEach() 的执行速度 < map() 的执行速度

map() 会分配内存空间存储新数组并返回，forEach() 不会返回数据。

forEach() 允许callback更改原始数组的元素。map() 返回新的数组。

find():返回当前数组满足要求的第一项元素，没有满足就返回undefined

findindex():返回当前数组满足要求的第一项元素下标，没有满足就返回undefined

filter():返回当前数组满足要求的所有项，返回的是一个新数组

reduce():接收五个参数  第一个参数是一个回调函数包含（四个参数）第一个参数用来计数的。第二个参数是每一项元素；第三个参数当前参数的下标；第四个参数是当前数组；最后一个是起始值
```



#### 14.什么是闭包，闭包有那些优缺点

```
在一个函数内部创建的函数，这个内部函数可以访问外部函数的变量和参数。闭包使得外部函数的变量被内部函数引用时不会被释放，即使外部函数已经执行完毕（闭包就是能够读取其他函数内部变量的函数）

作用：延长变量作用域、在函数的外部可以访问函数内部的局部变量，但是容易造成内层泄露，闭包中的局部变量永远不会被回收

优点：     1:变量长期驻扎在内存中；
           2:避免全局变量的污染；
           3:私有成员的存在 ；
缺点:
    常驻内存 会增大内存的使用量 使用不当会造成内存泄露，详解：

（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。


第二种回答方式
闭包的缺点：
滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量
因为垃圾回收机制，只会回收变量。清空没用被调用函数的作用域
只要形成闭包，作用域就不能被销毁，因为闭包存在的意义，就是保护闭包内的变量不被外部影响
如果将函数内部的变量return出来，只是return出来这一个值
而闭包，return的是，整个闭包函数的作用域，提供给外部使用，依旧保持函数内部结构

清除闭包：把闭包赋值为null
```



### *15.项目介绍*

```
权限管理模块怎么实现的下边有，页面级按钮权限下边也有，往下翻，其他自由发挥
```



#### 16.keep-alive是干什么的，讲一下它的生命周期

```
	keep-alive是进行组件缓存的，在需要缓存的路由配置中设置自定义属性keep-alive:true ，组件被切换时有两种情况，默认被销毁，但是被KeepAlive包裹的路由出口的组件会被缓存起来
	
	被缓存的组件会产生两个新的生命周期函数activated和deactivated
	重新进入被缓存的组件时会走activated,离开时走deactivated
	
	当然在不需要缓存的组件的时候，在路由出口中使用v-if判断自定义属性是否为true,在不需要缓存的路由出口中设置v-if取反
	activated(): 当被包裹的组件被激活时这个生命周期函数会被调用。
	deactivated(): 当被包裹的组件被切换时这个生命周期函数会被调用。
```



#### 17.讲一下防抖和节流，防抖和节流的应用场景

```css
防抖:防止事件短时间内被频繁触发,使多次触发只有一次生效,前面N多次触发都会被忽略
	（手写防抖）
		var timer=null;
		btn.onclick=()=>{
			clearTimeOut(timer)
			timer=setTimeOut(()=>{
				conslole.log('防抖了')
			},1000)
		}
	
	
节流:防止事件短时间被频繁触发,减少事件触发的频率,因此,节流是有选择性的执行一部分事件
	(手写节流)
		var flg=true;
		btn.onclick=()=>{
			if(flg){
				flg=false；
				consloe.log('节流了')
				setTimeOut(()=>{
					flg=true
				},1000)
			}
		}
		
		
引用lodash库进行防抖节流
防抖：btn.onclick=_.debounce(function(){
                    console.log('防抖执行了')
                     }，1000)
节流：btn.onclick=_.throttle(function(){
                    console.log('节流执行了')
                     }，1000)                     
		
```

#### 18.如何进行项目优化？

```
一、 加载优化（减少http请求数）

二、图片优化 图片懒加载
1. 尽可能的使用PNG格式的图片，它相对来说体积较小，可以使用工具压缩，在上线之前最好进行一定的优化。

2. 同时在代码中进行图片的延迟加载，也叫做赖加载。

3. 避免a、img、iframe等标签的src属性为空：空src会重新加载当前页面，影响速度和效率。

4. 图像尽量避免使用DataURL：DataURL图像没有使用图像压缩算法，文件会变大，并且要解码后再渲染，加载慢耗时长。


三、使用CDN

四、开启Gzip（代码压缩）


六、减少不必要的Cookie
Cookie存储在客户端，伴随着HTTP请求在浏览器和服务器之间传递，由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，从而会影响加载速度，所以尽量减少不必要的Cookie。

七、脚本优化

八、前端代码结构的优化		组件封装	代码语义化

九、SEO优化

十、路由懒加载
```



#### 19. 如何解决跨域的

```js
使用propx进行反向代理

vue.confog.js 项目的根目录下

module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:7788',
        ws: true,
        changeOrigin: true,
        pathRewirte:{ //路径重写
             '^/api':''
         }
      },
      '/foo':{
          target:'http://localhost:3001'
        
      }
    }
  }
}

使用JSONP解决跨域
交给后台CORS解决



1、CORS (Cross-Origin Resource Sharing)：CORS 是当前主流的解决跨域问题的方案，它通过在服务端设置响应头来指定允许的源（域名）。前端发送跨域请求时，浏览器会检查响应头中的 CORS 设置，并决定是否允许请求。

2、JSONP (JSON with Padding)：JSONP 是一种通过动态创建 <script> 标签来实现跨域请求的方法。通常，后端返回一个函数调用（padding），并且将数据作为参数传递给该函数。前端在页面中定义对应的函数，以接收并处理返回的数据。

3、代理服务器（Proxy）：在开发环境中，可以通过设置代理服务器来转发请求，将跨域请求转换成同源请求。例如，可以使用 webpack-dev-server 的 proxy 选项或使用 http-proxy-middleware 中间件。

4、WebSocket：WebSocket 是一种全双工通信协议，它与 HTTP 协议不同，可以避开跨域限制。通过在前端和服务端之间建立持久连接，可以实现实时数据的传输和通信。

5、使用反向代理：可以通过配置反向代理服务器（如 Nginx）来解决跨域问题。反向代理服务器接收前端的请求，并代理到后端 API 服务器，使得前端与反向代理服务器之间存在同源关系。
```



#### 20.如何解决适配的



```js
1、使用rem进行适配
function setRem() {
        var ui_w = 375;
        var clientWidth = document.documentElement.clientWidth || document.body.clientWidth;
 
        var html_ = document.getElementsByTagName('html')[0];
        html_.style.fontSize = (clientWidth / ui_w) * 10 + 'px';
    }
    window.onresize = setRem;
    window.onload = setRem;


2、响应式布局：使用媒体查询和弹性布局等
   
```



#### 21.this的指向有那些？

```
	1、普通函数中的this指向window
	2、自执行函数中的this 指向window
	3、定时器中的this指向window
	4、计时器中this指向window
	5、在事件调用函数中，this指向当前事件的调用者
	6、在对象方法中，this指向当前对象
	7、在构造函数中this，指向当前构造函数创建的实例对象
	8、在构造函数的原型对象中,this指向当前构造函数的实例对象
	9、在类方法中，this指向类的实例对象
	10、箭头函数中，箭头函数本没有this，它的this是父级普通函数的this，如果箭头函数没有父级函数，则this指向window
```

 

#### 22.组件的使用

```
1.使用import *** from "路径" 引入组件
2.在component 中注册
3.在需要使用的组件中使用就行了
```

#### 23.首屏优化

```css
1、vue-router路由懒加载

2、使用CDN加速，将通用库从vendor进行抽离

3、Nginx开启Gzip

4、异步组件

5、服务器渲染SSR

6、按需加载UI库

7、webpack开启gzip压缩

8、图片懒加载减少占用带宽

9、页面使用骨架屏

10、js脚本使用异步和延迟
```

#### 24.data为什么是一个函数？

```css
	如果data是一个对象，当每个组件的data同时使用时，指向的是同一个内存地址，相当于一个浅拷贝
	
	如果data设置成函数，return出来，相当return出来一个新对象，通过对象返回值的形式，保证组件之间的数据，不被污染。
	
	每次调用data中的数据，都会返回一个对象，对象之间是相互独立的。对象之间的相等，是通过内存地址判定的，每次返回一个新的对象，都需要在内存中开辟一个新的空间，所以这些对象每次都是不一样的，都具有数据的独立性
```

#### 25.http状态码都有那些？

```css
1xx（信息性状态码）：表示请求已被接收，继续处理。
100 Continue：服务器已经收到请求头，并且客户端应该继续发送请求体。

2xx（成功状态码）：表示请求已成功被服务器接收、理解和处理。
200 OK：请求成功。
201 Created：请求成功并在服务器上创建了新的资源。
204 No Content：请求成功，但响应中没有实体内容。

3xx（重定向状态码）：表示资源位置发生变动，需要进一步操作才能完成请求。
301 Moved Permanently：请求的资源已永久移动到新位置。
302 Found：请求的资源临时移动到新位置。
304 Not Modified：资源未被修改，重定向缓存。

4xx（客户端错误状态码）：表示客户端提交的请求有错误或无法处理。
400 Bad Request：请求参数有误。
401 Unauthorized：未经授权，需要身份验证。
403 Forbidden：服务器拒绝请求。
404 Not Found：请求的资源不存在。

5xx（服务器错误状态码）：表示服务器无法处理请求。
500 Internal Server Error：服务器内部错误。
502 Bad Gateway：网关错误。
503 Service Unavailable：服务器当前无法处理请求。
504 Gateway Timeout：网关超时。
```

#### 26.讲讲路由守卫

```css
路由守卫可以帮助我们在路由切换前后执行一些自定义的逻辑，例如权限验证、路由重定向、数据加载等操作。通过使用这些守卫，我们可以更好地控制和管理Vue应用程序的路由行为。
    
Vue的路由守卫包括全局守卫、路由独享守卫和组件内守卫。
全局守卫：
	全局守卫是在整个应用程序的路由生命周期中触发的。常见的全局守卫包括：
		beforeEach：在路由切换前触发，可以用来进行权限验证或重定向等操作。全局路由前置守卫
		afterEach：在路由切换后触发，可以用来进行一些全局的善后处理操作。全局路由后置守卫
		beforeResolve：在路由解析之前触发，用于确保异步路由组件加载完成。
        
路由独享守卫：
	路由独享守卫是在特定的路由配置中定义的。它们会在路由切换到对应的路由时触发。常见的路由独享守卫包括：
    	beforeEnter：在进入特定路由前触发，可以用于验证或重定向等操作。
        
组件内守卫：
	组件内守卫是在组件内部配置的。常见的组件内守卫包括：
		beforeRouteEnter：在进入当前组件前触发，但是在组件实例化之前，因此无法直接访问组件实例。
		beforeRouteUpdate：在当前组件复用时触发，例如，从 A 路由切换到 B 路由再切回 A 路由时，A 组件会触发此守卫。
		beforeRouteLeave：在离开当前组件前触发，可以用于提示用户是否保存未提交的表单或执行其他离开前的操作。

```

#### 27.子组件如何修改父组件的值

```js
1.如果子组件要修改来自父组件的值，不能直接修改，要通过事件进行修改

2.首先子组件中点击事件绑定方法，  
<el-button @click="chengeData">
    点我改变父组件的值
</el-button>

方法调用$emit()事件，通过这个方法发送请求给父组件，
methods:{
    //通过方法请求给父组件改变值
    chengeData(){
        this.$emit("chengeComponent1Data",1)
    }
}
同时这个方法有两个参数，第一个是方法名（此方法名在父组件中用到）。第二个是父组件中方法的参数。

父组件绑定方法接收这个请求。（绑定的方法要和子组件传来的方法一样，即父组件中@后面的方法要个子组件中$emit()中的第一个参数一样）




1、使用props和$emit：
父组件可以通过props将需要修改的值传递给子组件。
在子组件中，通过this.$emit('eventName', value)触发一个自定义事件，并携带需要修改的值。
父组件监听这个自定义事件，在事件处理函数中更新需要修改的值。

2、使用.sync修饰符（Vue 2.x）：
父组件通过props将需要修改的值传给子组件，并使用.sync修饰符：
<child-component :value.sync="parentValue"></child-component>
在子组件内部，通过修改this.$emit('update:value', newValue)来更新父组件的值。

3、使用v-model指令（Vue 2.x）：
在父组件上使用v-model指令将值传递给子组件：
<child-component v-model="parentValue"></child-component>
子组件接收到的值将存储在名为value的prop上，并且在更新时触发一个名为input的自定义事件：
this.$emit('input', newValue);
这样，父组件中的v-model指令将会自动更新父组件的值。
```

#### 28.ajax封装

```js
<script>
        // 1、创建对象
       var ajax_ = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTT');
        //2、建立连接
        ajax_.open('get','http://jsonplaceholder.typicode.com/posts',true);
        //3、发送请求
        ajax_.send();
        //4、接收服务器数据
        ajax_.onreadystatechange = function(){
           /*  if(ajax_.readyState==4 &&ajax_.status == 200 ){
                console.log(ajax_.responseText);
            } */

            if(ajax_.readyState==4){
                if(ajax_.status==200){
                    console.log(ajax_.responseText);
                }else{
                    console.log('获取连接失败');
                }
            }
        }
      
</script>
```



#### 29.Axios二次封装（看得懂的说，看不懂别胡咧咧）

```js
// 二次封装 axios 的文件 request.js
import axios from "axios";
const service = axios.create({
  baseURL: '',
});
// 请求拦截器
service.interceptors.request.use(
   config => {},
   error => {}
    
    return config
);
// 响应拦截器
service.interceptors.response.use(
  response => {},
  error => {}
);
export default service;
 
 
// api 文件引入 request.js
import request from './request';
request({
    url: "/person/detail?id=" + id,
    method: "get",
});







创建一个名为api.js的文件，在其中完成Axios的二次封装：
import axios from 'axios';

// 创建一个Axios实例
const service = axios.create({
  baseURL: 'http://api.example.com', // 设置请求的基础URL
  timeout: 5000, // 设置请求超时时间
});

// 请求拦截器，可以在发送请求前做一些预处理
service.interceptors.request.use(
  config => {
    // 在发送请求之前可以设置请求头等操作
    // 例如，添加Token到请求头
    config.headers['Authorization'] = 'Bearer ' + getToken();
    return config;
  },
  error => {
    // 处理请求错误
    console.error(error);
    return Promise.reject(error);
  }
);

// 响应拦截器，对响应进行统一处理
service.interceptors.response.use(
  response => {
    const res = response.data;
    // 在这里可以根据后端返回的状态码进行处理
    if (res.code !== 200) {
      // 例如，抛出一个错误
      return Promise.reject(new Error(res.message || '请求失败'));
    } else {
      return res; // 请求成功，返回响应数据
    }
  },
  error => {
    console.error('响应错误:', error);
    return Promise.reject(error);
  }
);

export default service;

利用封装好的api.js进行网络请求：
import request from './api';

// 创建一个API函数，用于发送具体的请求
export function getUserInfo(userId) {
  return request({
    url: '/user/info',
    method: 'get',
    params: { userId: userId }
  });
}
```



#### 30.vue首屏加载闪烁

```js
在css中添加
[v-clock]{
    display:none
}
```

#### 31.uni-app打包问题

```
Uni-app 是一个跨平台的开发框架，它能够将代码编译成多个平台的应用程序，包括iOS、Android、H5 等。在打包过程中，可能会遇到一些问题。以下是一些常见的 Uni-app 打包问题及解决方案：

打包后应用运行异常：如果在运行打包后的应用时出现异常或错误，可以尝试以下解决方案：

清除缓存：运行 npm run clean 命令，清除项目的缓存文件，然后重新打包。
检查插件和依赖：确保插件和依赖的版本与 Uni-app 的要求相匹配，并根据需要进行更新。
运行调试模式：在开发工具中启用调试模式，检查控制台日志以获取更多的错误信息，帮助定位问题。
打包后应用体积过大：如果打包后应用的体积过大，可以尝试以下优化措施：

图片压缩：对图片进行压缩处理，使用合适的图片格式（如 WebP）来减小文件大小。
删除无用资源：检查项目中是否存在未使用的资源文件，删除无用资源可以减小应用的体积。
使用动态加载：将一些较大的模块或组件设计为按需加载，避免一次性加载所有资源。
打包后应用在某些平台异常：如果打包后应用在某些平台上出现异常或不正常的行为，可以尝试以下方法：

查看官方文档：查看对应平台的官方文档，了解该平台对 Uni-app 的支持情况和限制，并根据需要进行调整。
检查插件和依赖：确保使用的插件和依赖在目标平台上均支持，并且版本与 Uni-app 的要求相匹配。
调试和测试：在目标平台上进行调试和测试，定位问题，并根据需要进行修复或调整。
```

#### 32.$nextTick

```css
是 Vue.js 框架提供的一个方法，用于在下次 DOM 更新循环结束之后执行延迟回调函数。它可以用于确保在修改数据后，等待 Vue.js 完成视图更新后再执行特定的逻辑。

常见的用法是在修改数据之后，使用 $nextTick 来执行需要等待更新后的 DOM 操作或获取更新后的属性值。

一、作为实例方法：在组件的方法中直接通过 this.$nextTick 来调用。
二、、作为 Promise：在没有提供回调函数的情况下，$nextTick 也可以返回一个 Promise，可以使用 await 或 .then() 来处理延迟操作。

```



#### 33.cookie 、localstorage 、 sessionstrorage 之间有什么区别？

![img](https://img-blog.csdnimg.cn/20210521210612392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bl9zaHVv,size_16,color_FFFFFF,t_70)

```css
1.Cookies 存储的数据会随着 HTTP 请求发送到服务器端，需要通过HTTP 请求和响应头中的 Set-Cookie 和 Cookie 信息来在客户端和服务端进行传输。而localStorage 和 sessionStorage 数据仅存储在客户端。

2.Cookies 存储的数据大小限制为 4KB 左右，因此无法存储大量数据，而 sessionStorage 和 localStorage 数据存储的大小一般为5MB 左右。

3.Cookies 存储的数据具有时效性，可以设置过期时间，过期后将被浏览器自动删除。而 sessionStorage 和 localStorage 数据则可以长期存储，除非被显式地删除或者清除浏览器缓存。

4.Cookies 存储的数据由服务器端设置，可以通过 JavaScript 在客户端读写。sessionStorage 和 localStorage 则完全在客户端进行读写，无法通过服务端进行干预。

5.Cookies 存储的数据会随着 HTTP 请求发送到服务器端，因此会产生一定的性能损失，而 sessionStorage 和 localStorage 则可以在客户端进行快速读取和写入，性能更高。
```



#### 34.检测数据类型

```js
1.typeof
    typeof判断所有变量的类型，返回值有number、string、boolean、function、object、         undefined。
    typeof对于丰富的对象实例，如数组，日期只能返回object，导致有时候得不到真实的数据类型。
    
2.instanceof
    instanceof用来判断对象，代码形式（obj1 instanceof obj2）（判断obj1是否为obj2的实       例），obj2必须为构造函数或者对象，否则会报错。返回的是布尔值。  用来精准的判断，对象是否是     由某构造函数创造出来的，结果是true 或者false （亲子鉴定）
3.constructor
  constructor 用来查找当前对象的构造函数的（找爸爸）
注意：
 constructor  后面一定要是对象类型，并且大小写不能错
可以判断基本类型（string、number、boolean）
不能判断基本类型（null、undefined）
可以判断复杂类型数据
对象直接继承和间接继承都会影响判断结果

4.Object.prototype.toString.call() 

5.jquery.type()

6.isNaN() 判断是不是数字
```



#### 35.如何终止for循环 return break  continue

```js
continue 当程序运行到 continue； 语句时，会终止当前的这一次循环，进入下一次的循环中。
它 适用于所有的循环结构。

break 当程序运行到 break; 语句时，会结束当前的循环，执行循环后面（外边）的语句。
如果多层循环，只会退出当前的循环，执行该循环后的语句，外循环不受影响。
一般配合判断语句使用

return 当程序运行到 return; 语句时，会终止循环，结束当前方法。
```



#### 36.路由模式

```css
路由有三种模式，hash、history和abstract
1.hash路由在地址栏URL中的哈希值（#），而history优点是URL看起来更加干净，没有哈希值。

2.我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，后端准备对应的地址时会报错）【hash模式，#后面的数据，不会请求发送给后台，history会】

3.hash路由支持低版本的浏览器，而history路由是HTML5新增的API。

4.hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。

5.history运用了浏览器的历史记录栈，之前有back,forward,go方法，之后在HTML5中新增了pushState()和replaceState();通过使用pushState()和replaceState()方法提供了对浏览器历史记录进行修改的能力。通过	调用这两个方法，可以改变当前URL而不会立即向后端发送请求。

	pushState()方法可以将一个新的状态(push)添加到浏览器的历史记录栈中，并改变当前URL。使用该方法时，不会刷新页面，也不会向服务器发送请求。可以将自定义的状态对象和新的URL作为参数传入。

replaceState()方法可以修改当前状态，替换当前的URL。它与pushState()类似，但是不会新增一个状态到历史记录栈中，只会直接替换当前的状态。也不会刷新页面或向服务器发送请求。

这两个方法结合历史模式，可以实现前端页面的路由切换和URL的变化，而无需重新加载页面或与服务器进行通信。这为单页面应用（SPA）提供了更流畅的用户体验和更好的性能优化。
   
6、抽象模式（Abstract mode）: 
	1、这种模式在Vue Router中并没有特殊的名称，它基于浏览器环境或服务端环境来自动选择哈希模式或	历史模式

	2、在浏览器环境下，默认使用历史模式，如果不支持则自动降级使用哈希模式。

	3、在服务端环境下，通常使用哈希模式。
```



#### 37.diff算法

```js
diff 算法就是对虚拟 dom 进行对比，并返回一个 patch 对象，这个对象的作用是存储两个节点不同的地方，最后用 patch 里记录的信息去局部更新真实的 dom

diff 算法的步骤
1.js 对象表示真实的 dom 结构，就是我们说的生成一个虚拟 dom，再用虚拟 dom 构建一个真的 dom 树，放到页面中。
2.状态改变的时候生成一个新的虚拟 dom 跟旧的进行对比，这个对比的过程就是 diff 算法，通过 patch 对象记录差异 
3.把记录的差异用在第一个虚拟 dom 构建的真实的 dom 上，视图就更新了


vue 为什么要用虚拟dom：
因为传统的dom操作，只要一个节点更新，整个页面都需要发生重绘，效率比较低
vue2中，采用snabbdom库，自动的帮我们生成虚拟的dom，把虚拟的dom和真实的dom进行对比，虚拟dom和真实dom一致的节点对象，则不再更新，只更新不同的节点，不同的节点以虚拟dom为主
在这个过程当中，真实dom和虚拟dom的对比，使用的是diff算法
kev值的作用，可以使虚拟dom和真实dom快速的对比
如果没有key值，则两个dom对象，只能通过循环遍历，判断所有的属性值是否一致来判断是否为相同节点，效率比较低
如果有key值，只需要判断key值是否相同，通过该判断，来判断是否为相同节点，所以说key值要绑定一个唯一的值，最好用后台返回数据的id
```



#### 38.什么是虚拟dom

```css
虚拟 DOM （Virtual DOM ）

实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上

在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的命名可能会有差别

创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应
```



#### 39.vue3对虚拟dom有哪些优化

```js
   1、静态树提升（Static tree hoisting）：Vue 3 可以对静态的 VNode 进行提升，这样它们在渲染过程中就不再需要创建和比对。这大大减少了渲染所需的时间和开销。
  2、缓存事件处理函数：Vue 3 使用了更高效的方法来处理事件，避免了每次渲染时都重新创建事件处理函数。相反，它会缓存处理函数，从而提供更好的性能。
  3、静态属性提升（Static attr hoisting）：Vue 3 可以将静态属性（如 class、style）提升到组件的根节点上，这样可以减少虚拟 DOM 的大小，并且提高渲染性能。
  4、静态节点提升（Static node hoisting）：Vue 3 可以将静态节点（即不会改变的节点）提升到渲染函数之外，这样可以减少虚拟 DOM 的创建和比对，从而提高性能。
 5、缓存子树（Cached sub-tree）：Vue 3 可以缓存子树，避免重复创建和比对，从而提高渲染性能。
这些优化措施使得 Vue 3 在性能方面有了明显的提升，能够更高效地处理复杂的组件渲染和更新。
```



#### 40.ts中的属性有那些修饰符

```js
属性修饰符
公共public：在类里面，子类 类外面都可以访问（默认）

私有private：在类里面，子类 类外面都不可以访问

保护protected： 保护类型  在类里面，子类 都可以访问  ，类外面无法访问
```



#### 41.ts中有那些数据类型

```js
ts的数据类型有：布尔值、数字、字符串、数组、元组、枚举、any、void、null和undefined、never、object unknown
(元组：固定长度的数组)；(枚举：一组固定的常量)
数组中又分为数组泛型，Array<元素类型>
    
元组类型允许表示一个一直元素数量和类型的数组，个元素的类型不必相同

any为那些在编程阶段还不清楚类型的变量指定一个类型
```



#### 42.ts与js的区别

| ts                                           | js                                         |
| -------------------------------------------- | ------------------------------------------ |
| JavaScript的超集用于解决大型项目的代码复杂性 | 一种脚本语言，用于创建动态网页             |
| 可以在编译期间发现并纠正错误                 | 作为一种解释型语言，只能在运行时发现错误   |
| 强类型，支持静态和动态类型                   | 弱类型，没有静态类型选项                   |
| 最终被编译成JavaScript代码，让浏览器解析     | 可以直接在浏览器中使用                     |
| 支持模块，泛型和接口                         | 不支持模块，不支持泛型或接口               |
| 支持ES3 ES4 ES5 ES6+功能                     | 不支持编译其他 ES3 ES4 ES5 ES6+功能        |
| 社区的支持仍在增长，而且还不是很大           | 大量的社区支持以及大量文档和解决问题的支持 |



#### 43.什么是事件委托

```js
事件委托也叫做事件代理，把触发子元素的事件，通过事件冒泡让其父元素触发事件
```



#### 44.事件循环even loop

```javascript
事件循环：只要主线程空（代表同步任务执行完了），就会去读取任务队列，这都是JavaScript的运行机制，整个过程会不断重复

JS是单线程的，意味着同一时间只能做一件事，但是并不意味着阻塞，实现单线程非阻塞的方法就是事件循环
```

#### 45.父组件与子组件生命周期执行顺序

```

在Vue 2中，父子组件的挂载和销毁顺序是按照以下步骤进行的：

1.挂载阶段(Mounting Phase):

父组件beforeCreate钩子函数被 调用。
在创建父组件之前创建钩子函数被调用。
父组件created钩子函数被调用。
父组件创建了钩子函数被调用。
父组件beforeMount钩子 函数被调用。
父组件在钩子函数被调用山之前。
子组件beforeCreate钩子函数被调用。
在创建子组件之前创建钩子函数被调用。
子组件created钩子函数被调用。
子组件创建了钩子函数被调用。
子组件beforeMount钩子 函数被调用。
子组件在钩子函数被调用山之前。
子组件mounted钩子函数被调用。
子组件挂载钩子函数被调用。
父组件mounted钩子函数被调用。


2.销毁阶段(卸载阶段)：

父组件beforeDestroy钩子函数被调用。
父组件，钩子函数被调用.
子组件beforeDestroy钩子函数被调用。
子组件，钩子函数被调用.
子组件销毁 destroyed。
父组件destroyed钩子函数被调用。
父组件摧毁了钩子函数被调用。

需要注意的是：子组件的销毁是在父组件销毁之前进行的。这是因为父组件可能会依赖子组件进行操作,所以在父组件销毁之前，先销毁子组件可以确保数据的完整性和操作的正确性。
```



#### 46.call 、apply 、bind 的区别

| bind                                                     | call                                            | apply                                          |
| -------------------------------------------------------- | ----------------------------------------------- | ---------------------------------------------- |
| 第一个参数是this要指向的对象，多个参数 类型不限          | 第一个参数是this要指向的对象，多个参数 类型不限 | 第一个参数是this要指向的对象，第二个参数是数组 |
| bind()改过this后，不执行函数，会返回一个绑定新this的函数 | call()改过this的指向后，会再执行函数            | 改过this的指向后，会再执行函数                 |

#### 47.小程序的跳转方式和区别



##### 1.wx.navigateTo({})

> 保留当前页面，跳转到应用内的某个页面，使用 `wx.navigateBack` 可以返回;

**关于Url参数：**

- 不能跳转到tabBar页面
- 带参格式：【路径】?【参数键1】=【参数值】& 【参数键2】=【参数值】



```jsx
wx.navigateTo({
    url:'../test/test?id=1&page=4',//跳转页面的路径，可带参数？隔开，不同参数用 & 分隔；相对路径，不需要.wxml后缀
    success:function(){}        //成功后的回调；
    fail：function(){}          //失败后的回调；
    complete：function(){}      //结束后的回调(成功，失败都会执行)
})

传递的参数在接收页面onLoad()函数中得到值：option.id就可以得到了
onLoad: function (option) {
　　console.log(option)//可以打印一下option看查看参数
    this.setData({
        id:option.id,
});
```

##### 1.1.wx.navigateBack(OBJECT)

> 关闭当前页面，返回上一页面或多级页面。
>  可通过 getCurrentPages()) 获取当前的页面栈，决定需要返回几层。

**关于参数:**

> delta-->类型：Number，
>  默认值：1 ，
>  说明：返回的页面数，如果 delta 大于现有页面数，则返回到首页。

**注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码**



```php
// 此处是A页面
wx.navigateTo({
  url: 'B?id=1'
})

// 此处是B页面
wx.navigateTo({
  url: 'C?id=1'
})

// 在C页面内 navigateBack，将返回A页面
wx.navigateBack({
  delta: 2
})
```

##### 2.wx.redirectTo(OBJECT)

> `关闭`（之前的页面是回不去的）当前页面，跳转到非tabBar的某个页面

**关于Url参数：**

- 不能跳转到tabBar页面
- 【路径】?【参数键1】=【参数值】& 【参数键2】=【参数值】

##### 3.wx.reLaunch(OBJECT)

> `关闭`（之前的页面是回不去的）所有页面，打开到应用内的某个页面。

**关于Url参数：**

- 【路径】?【参数键1】=【参数值】& 【参数键2】=【参数值】
- 【如果是跳转到tabBar页面，则不能带参数】

##### 4.wx.switchTab(OBJECT)

> 跳转到tabBar的某个页面，并关闭`其他所有非 tabBar 页面`

**关于参数：**

- 目标页面必须是在：app.json 的 tabBar 中定义的页面
- 不能带参数

```css
wx.switchTab({ 
    url: '/pages/home/home' 
});
```

##### 5.组件  <navigator>

> 直接写在布局里面的跳转方式

**参数说明：**

- url:和上面几种方式的规则一样，当前小程序内的跳转链接
- open-type（跳转方式）：有效值如下表
   参数|说明
   navigate    |对应 wx.navigateTo 或 wx.navigateToMiniProgram 的功能
   redirect    |对应 wx.redirectTo 的功能
   switchTab  |对应 wx.switchTab 的功能
   reLaunch    |对应 wx.reLaunch 的功能
   navigateBack    |对应 wx.navigateBack 的功能

```xml
<navigator url="/pages/detail/detail">点击跳转</navigator>
```

#### 48.token失效之后怎么解决

```css
1、使用刷新令牌（Refresh Token）
在用户登录时，除了发放一个访问令牌（Access Token），再发放一个刷新令牌（Refresh Token）。
访问令牌的有效期比较短，刷新令牌的有效期比较长。当访问令牌过期时，使用刷新令牌向服务器请求新的访问令牌。如果刷新令牌也过期，则需要重新登陆。

2、重新登录
当访问令牌过期时,需要重新登录重新获取有效token。这是最简单的一种方式，但可能会影响用户体验。

3、滑动窗口
用户每次使用使用访问令牌时，服务器都会更新访问令牌的过期时间。
这种方式的优点是用户只要频繁访问，就不需要登录，但可能会增加服务器负担。
```

#### 49.Vuex辅助函数及作用

```css
1. mapState: 将Vuex store中的state状态映射到组件的computed计算属性中，使组件可以直接访问store中的状态值。

2. mapGetters: 将Vuex store中的getters映射到组件的computed计算属性中，使组件可以直接访问store中的计算属性。

3. mapMutations: 将Vuex store中的mutations映射到组件的methods方法中，使组件可以直接调用mutations中的方法来修改store
中的状态。

4. mapActions: 将Vuex store中的actions映射到组件的methods方法中，使组件可以直接调用actions中的方法来触发一些异步操作或者复杂的业务逻辑。
```



#### 50.HTTP和HTTPS与的区别

```css
1、安全性不同:HTTP是明文传输;HTTPS通过SSL/TLS加密传输,增加了数据传输的安全性;

2、传输方式不同:HTTP使用 TCP/IP 协议进行数据传输。HTTPS使用 SSL/TLS 协议建立加密连接进行传输，并在传输数据之前进行加密和解密。

3、默认端口不同:HTTP默认端口是80,HTTPS默认端口是443

4、证书:HTTPS需要使用数字证书来进行身份验证。

5、SEO影响:HTTPS 网站在搜索排名中可能会优于仅使用HTTP的网站。因为HTTPS提供了更高的安全性和用户隐私保护，搜索引擎更倾向于向用户提供安全可信赖的网站。


http是明文传输安全性低，而https可以进行加密传输，身份认证。
http的默认端口是80，而https的默认端口是443。
```



#### 51.混入（mixin）

```js
他可以把多个组件中重复出现的属性和方法进行封装方便多次调用。
混入就是把公共的方法逻辑抽取出来放在一个公共的组件内,过里面可以写data数据和声明周期

1.创建一个mixin.js的文件在mixin.js中写

let mixin = {
    data(){
        return{
            str:'你好'
        }
    },
    created() {
        console.log("我是混入的生命周期函数")
    },
    methods: {
        showToast(){
            alert("我是混入中的方法啊!")
        }
    },
}
 
// 记住，最后一定要导出
export default mixin


2.在需要使用的组件中引入
import mixin from '../mixin/mixin.js'	// 首先引入这个混入对象
export default {
    mixins:[mixin],		// 然后注册你引入的这个混入对象
}
```



#### 52.微信请求路径错误和上线时候 的问题怎么解决









#### 53.小程序怎么实现分包

```
小程序分包，主包先加载，一个不超过2M，10个包，主卧同理
如图：程序运行，最先加载主包，其他在使用时会去加载，运行速度快
在app.json中，有pages,window,tabbar这些配置项，分包是subPackages
```



#### 54.echarts







#### 55.组件的二次封装如何实现







#### 56.数组的常用方法

```
1、push()
   向数组的末尾添加新内容
   参数：要添加的项。传递多个用逗号隔开，任何数据类型都可以
   返回值：新增后数组的长度
   是否改变原数组：改变
2、pop()
   删除数组的最后一项
   参数：无
   返回值：被删除的项
   是否改变原数组：改变
3、shift()
   删除数组的第一项
   参数：无
   返回值：被删除的项
   是否改变原数组：改变
4、unshift()
  向数组首位添加新内容
  参数：要添加的项，多项用','隔开
  返回值：新数组的长度
  是否改变原数组：改变
5、slice()
  按照条件查找出其中的部分内容
  参数：
  array.slice(n, m)，从索引n开始查找到m处（不包含m）
  array.slice(n) 第二个参数省略，则一直查找到末尾
  array.slice(0)原样输出内容，可以实现数组克隆
  返回值：返回一个新数组
  是否改变原数组：不改变
6、splice()
  对数组进行增删改
  增加：ary.splice(n,0,m)从索引n开始删除0项，把m或者更多的内容插入到索引n的前面
  返回空数组
  修改：ary.splice(n,x,m)从索引n开始删除x个，m替换删除的部分
  把原有内容删除掉，然后用新内容替换掉
  删除：ary.splice(n,m) 从索引n开始删除m个内容
  （如果第二个参数省略，则从n删除到末尾）
  返回删除的新数组，原有数组改变
7、join()
  用指定的分隔符将数组每一项拼接为字符串
  参数：指定的分隔符（如果省略该参数，则使用逗号作为分隔符）
  返回值：拼接好的字符串
  是否改变原数组：不改变
8、concat()
  用于连接两个或多个数组
  参数：参数可以是具体的值，也可以是数组对象。可以是任意多个
  返回值：返回连接后的新数组
  是否改变原数组：不改变
9、indexOf()
  检测当前值在数组中第一次出现的位置索引
  参数：array.indexOf(item,start) item:查找的元素 start:字符串中开始检索的位置
  返回值：第一次查到的索引，未找到返回-1
  是否改变原数组：不改变
  let ary9 = ['a','b','c','d','e','a','f'];   
  
  console.log(ary9.indexOf('c'));//2
  
  console.log(ary9.indexOf('a',3))//5
  
10、lastIndexOf()

   检测当前值在数组中最后一次出现的位置索引
   参数：array.lastIndexOf(item,start) item:查找的元素 start:字符串中开始检索的位置
   返回值：第一次查到的索引，未找到返回-1
   是否改变原数组：不改变
   let ary10 = ['a','b','c','d','e','a','f'];   
   console.log(ary10.lastIndexOf('c'));//2
   console.log(ary10.lastIndexOf('f',1))//-1

11、includes()
   判断一个数组是否包含一个指定的值
   参数：指定的内容
   返回值：布尔值
   是否改变原数组：不改变
   var ary13 = ['a','b','c','d']; 
   console.log(ary13.includes('c'));//true
   console.log(ary13.includes(2));//false
12、sort()
   对数组的元素进行排序（默认是从小到大来排序 并且是根据字符串来排序的）
   参数：可选(函数) 规定排序规则 默认排序顺序为按字母升序
   返回值：排序后新数组
   是否改变原数组：改变
   sort在不传递参数情况下，只能处理10以内（个位数）数字排序
   
   let ary11 = [32,44,23,54,90,12,9]; 
     ary11.sort(function(a,b){       
     // return a-b;  // 结果[9, 12, 23, 32, 44, 54, 90]
    // return b-a;  // 结果[90, 54, 44, 32, 23, 12, 9]   })  
      console.log(ary11);
   
13、reverse()

   把数组倒过来排列
   参数：无
   返回值：倒序后新数组
   是否改变原数组：改变
   let ary12 = [6,8,10,12]; 
   console.log(ary12.reverse());//[12, 10, 8, 6]

14、forEach()
   循环遍历数组每一项
   参数：函数 ary.forEach(function(item,index,ary){}) item:每一项 index:索引 ary:当前数组
   返回值：无
   是否改变原数组：不改变
   forEach中不能使用continue和break，forEach中不能跳出，只能跳过(return跳过)

   var ary14 = ['a', 'b', 'c', 'd'];
   var item = ary14.forEach(function (item, index, ary) {
        console.log(item, index, ary);
        //item: 表示当前数组的每一项   a b c d
        //index:表示当前数组的下标：   0 1 2 3
        //arry: 表示当前数组          ['a', 'b', 'c', 'd']
    })
 
   forEache没有返回值，主要用于判断某个值出现的次数
 
 //判断有几个a
    var ary14 = ['a', 'a', 'b', 'c', 'd'];
    var index = 0;
    ary14.forEach(function (item) {
        if (item == 'a') {
            index++;
        }
    })
    console.log(index);//2
    
15、some() 数组中每一项 只要有一个满足条件就返回true
    var arry = [11, 22, 33, 44];
    var bool = arry.some(function (item) {
        return item > 44;
    })
    console.log(bool);
16、every() 数组中每一项 必须全部满足条件就才会返回true
    var arry = [11, 22, 33, 44];
    var bool = arry.every(function (item) {
        return item > 11;
    })
    console.log(bool);
17、map() 遍历数组中的没一项 并对数据进行二次的处理 得到一个新数组

    var arry = [11, 22, 33, 44];
    var newArry = arry.map(function (item) {
        // console.log(item);
        return item + 1;
    })
    console.log(arry);
    console.log(newArry);// 12 23 34 45
    
18、filter() 过滤数组中的每一项，把满足条件的内容返回
		
    var arry = [11, 22, 33, 44];
    var newArry = arry.filter(function (item) {
        return item > 22;
    })
    console.log(newArry);//33 44
    
19、reduce()  求和
	var arry = [11, 22, 33, 44];
    var result = arry.reduce(function (sum, item) {
        return sum + item;
    }, 0)
   console.log(result);//110
```



#### 57.MVVM与MVC的区别

```
在Vue框架中，MVVM是指Model-View-ViewModel的架构模式。Model是数据模型，负责维护应用程序中的数据；View是用户界面，展示应用程序的数据；ViewModel是框架创建的一个观察者对象，负责View和Model之间的通讯和交互，将Model转化为View可以显示的数据。

在具体实现中，Vue框架通过数据劫持的方式来实现MVVM模式。Vue通过对组件实例的data选项进行监听，当数据发生变化时，会自动将变化通知ViewModel，然后ViewModel再去更新View，将最新的数据展示到界面上。这种机制保证了MVVM模式下View与Model之间的数据同步，使客户端可以实现响应式编程。

区别：
MVVM与MVC的最大区别就是：它实现了View和Model的自动同步，也就是当Model的数据改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变数据后该数据对应View层显示会自动改变。MVVM并不是用VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。

```



#### 58.如何实现一个元素居中，有几种方法

```
行内元素  （文本的水平垂直居中）

​    单行文本 text-align:center   固定高： line-height:高度
​                                无高： padding:30px 0;

​    多行文本  text-align:center  无高：padding:30px 0;
​                              固定高：display:table-cell
​                                    vertical-align: middle

块级元素：
​        固定高：  margin:  (父级元素的高-当前元素的高) /2  auto;
​      无固定高：  margin:auto
​                padding: 30px 0;

定位 和 位移：
​            需要水平垂直居中的元素  ： position:absolute

​            top:50%;

​            left:50%;

​            transform:translate(-50%,-50%)

​            父元素：position:relative

      
弹性布局：

​         需要水平垂直居中的父元素： display:flex;

​                               justify-content: center;

​                               align-items: center;
```



#### 59.HTML5 CSS3新特性

```
结构标签
header footer section nav aside article
增强型表单
input 的多个 type 如：email、numer、range、date
新增表单属性
placehoder required min max autofocus
高级选择器
first-of-type、last-of-type、only-of-type、only-child 、first-child、last-child、nth-child(n)
nth-of-type(n)、nth-last-of-type(n)、:before、:after
音频视频
audio video
其他
canvas
本地存储
localStorage
数据上限5MB左右（根据浏览器不同会有所区别）
无论打开还是关闭标签浏览器数据均保留
sessionStorage
数据上限5MB左右（根据浏览器不同会有所区别）
打开同源页面或刷新页面数据保留
关闭浏览器数据清空
打开或关闭新的浏览器窗口数据会被删除
cookie
数据上限4KB左右（根据浏览器不同会有所区别）
打开同源页面或刷新页面数据保留
关闭浏览器数据清空
打开或关闭新的浏览器窗口数据会被保留

!important 最高权重

背景定位和图片边框
盒子阴影
背景：
background-size：规定背景图片的尺寸（cover：填充；100% 100%：拉伸）
background-origin：规定背景图片的定位区域
对于 background-origin 属性，有如下属性:
背景图片可以放置于 content-box、padding-box 或 border-box 区域
边框：
border-radius：圆角
box-shadow / text-shadow：阴影
border-image：边框图片

2d 3d转换
动画过渡
```



#### 60.自定义指令

1、注册指令：在 Vue 组件中，使用 `directive` 方法来注册指令。

```
Vue.directive('directive-name', {
  // 指令选项
});
```

2、钩子函数：自定义指令可以定义一些钩子函数，用于处理不同的生命周期和事件。

- `bind`：指令第一次绑定到元素时调用。
- `inserted`：指令元素被插入到父元素时调用。
- `update`：指令所在的组件的 VNode 更新时调用。
- `componentUpdated`：指令所在的组件的 VNode 及其子 VNode 全部更新后调用。
- `unbind`：指令与元素解绑时调用。

```
Vue.directive('directive-name', {
  bind: function(el, binding, vnode) {
    // 指令绑定时的逻辑
  },
  update: function(el, binding, vnode, oldVnode) {
    // 指令更新时的逻辑
  },
  unbind: function(el, binding, vnode) {
    // 指令解绑时的逻辑
  }
});
```

3、使用指令：在组件的模板中，通过指令名称将指令绑定到相应的元素上。

```
<template>
  <div v-directive-name></div>
</template>
```



#### 61.SPA单页面开发的优缺点

```javascript
1.良好的交互体验
单页面应用的内容改变不需要重新加载整个页面，数据获取也是通过ajax异步获取的，没有页面之间的切换，就不会出现白屏现象，也不会出现假死并有闪烁现象，页面显示流畅，web更具有响应性
2.良好的前后端分离工作模式，后端不再负责渲染模板，后端API通用化，即同一套后端程序代码，不用修改就可以用于web界面，手机，平板等多种客户端
3.减轻服务器压力，服务器只用出数据就可以，不用展示逻辑和页面合成，吞吐能力会提高几倍
```

#### 62.for中的key的作用

```
vue 为什么要用虚拟dom
因为传统的dom操作，只要一个节点更新，整个页面都需要发生重绘，效率比较低
vue2中，采用snabbdom库，自动的帮我们生成虚拟的dom(h方法生成虚拟dom)，把虚拟的dom和真实的dom进行对比，虚拟dom和真实dom一致的节点对象，则不再更新，只更新不同的节点，不同的节点以虚拟dom为主(patch方法 完成新老节点的替换)

diff算法
在这个过程当中，真实dom和虚拟dom的对比，使用的是diff算法。

key值的作用
可以使虚拟dom和真实dom快速的对比
如果没有key值，则两个dom对象，只能通过循环遍历，判断所有的属性、值是否一致来判断是否为相同节点，效率比较低
如果有key值，只需要判断key值是否相同，通过该判断，来判断是否为相同节点，所以说，key值要绑定一个唯一的值，最好用后台返回数据的id
```



#### 63.内存泄漏出现场景

```js
1.遗忘的定时器或回调
2.闭包未释放
3.意外的全局变量引起的内存泄露
4.未清理的DOM元素引用
5.console.log()控制台日志记录对总体内存内置文件的影响，也是个重大的问题，同时也是容易被忽略的。记录错误的对象，可以将大量的数据保留在内存中。传递给console.log的对象是不能被垃圾回收，所以没有去掉console.log可能会存在内存泄漏~~~~
    
怎样避免内存泄露
1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；

2）注意程序逻辑，避免“死循环”之类的 ；

3）避免创建过多的对象 原则：不用了的东西要及时归还。
```

#### 64.小程序渲染原理

#### 65.页面渲染流程

```
1、构建DOM树

将HTML构建成一个DOM树，也就是构建节点，把所有的节点都构建出来。

2、构建CSSOM

解析css去构建CSSOM树

3、构建render树

DOM已经构建好了，css也有了，浏览器就会根据这两个来构造render树，浏览器就知道了有哪些节点、各个节点的CSS定义以及他们的从属关系。

4、布局

当render树有了，通过render树，浏览器开始计算各个节点的位置和样式。

5、绘制

遍历render树，在页面上绘制每个节点。

6、重排reflow

当render树绘制完成之后，比如JavaScript改变样式或添加节点，这时候render树就需要重新计算。

7、重绘repaint

既然重排了，最后当然得重新绘制页面。

HTML整个解析过程看起来很简单，但是我们要知道解析过程中css、js和dom的加载顺序。我们都知道HTML是自上往下解析的，在解析过程中：

1、如果遇到link和style，那就就会去下载这些外部的css资源，但是css跟DOM的构建是并行的，就是说不会阻塞DOM树的构建。

2、如果遇到script，那么页面就会把控制权交给JavaScript，直到脚本加载完毕或者是执行完毕。

3、页面的渲染是依靠render树，也就是说如果css没有加载完成，页面也不会渲染显示。

4、JavaScript执行过程中有可能需要改变样式，所以css加载也会阻塞JavaScript的加载。

5、JavaScript执行过程中如果操作DOM，但是DOM树又是在JavaScript之后才能构建，就会报错，找不到节点。

这就是HTML的渲染过程，因为DOM和css并行构建，我们会把css用外部引入，可以更快的构建DOM，因为JavaScript会阻塞DOM和css构建，且操作DOM一定要在DOM构建完成，我们选择把script放在最下面。如果我们过多的在render渲染完成后改变render，那么重排和重绘就会一直被动重发执行，这也会造成渲染速度变慢
```

#### 66.网络请求TCP  三次握手  四次挥手

```
举个栗子：把客户端比作男孩，服务器比作女孩。用他们的交往来说明“三次握手”过程：

（1）男孩喜欢女孩，于是写了一封信告诉女孩：我爱你，请和我交往吧！;写完信之后，男孩焦急地等待，因为不知道信能否顺利传达给女孩。

（2）女孩收到男孩的情书后，心花怒放，原来我们是两情相悦呀！于是给男孩写了一封回信：我收到你的情书了，也明白了你的心意，其实，我也喜欢你！我愿意和你交往！; 写完信之后，女孩也焦急地等待，因为不知道回信能否能顺利传达给男孩。

（3）男孩收到回信之后很开心，因为发出的情书女孩收到了，并且从回信中知道了女孩喜欢自己，并且愿意和自己交往。然后男孩又写了一封信告诉女孩：你的心意和信我都收到了，谢谢你，还有我爱你！ 女孩收到男孩的回信之后，也很开心，因为发出的情书男孩收到了。

由此男孩女孩双方都知道了彼此的心意，之后就快乐地交流起来了~~ 这就是通俗版的“三次握手”，期间一共往来了三封信也就是“三次握手”，以此确认两个方向上的数据传输通道是否正常。
```



#### 67.移动端有哪些常见的问题，都是怎么解决的？

```
点击事件300MS延迟问题 解决方案：下载fastclick的包
```

#### 68.  0.1+0.2为什么不等于0.3

```javascript
因为浮点数运算的精度问题。在计算机运行过程中，需要将数据转化成二进制，然后再进行计算。

js中的Number类型遵循IEEE754标准，在IEEE754标准的64位浮点数相加，因为浮点数自身小数位数的限制而截断的二进制在转化为十进制，就变成0.30000000000000004，所以在计算时会产生误差。

小数转化为IEEE754的过程：先转化为二进制的形式，然后再用科学计数法表示，接着把通过科学计数法表示的二进制数用IEEE754标准表示。

解决方法：
使用Math类中的toFixed()方法，保留你需要的小数点位数。

    var num1 = 0.1;
    var num2 = 0.2;
    var num3 = num1 + num2;
    //保留两位小数
    num3 = num3.toFixed(2) - 0;
    console.log(num3);//0.3
    console.log(typeof num3);//number
```



### 69.权限管理实现思路

```js
登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。
权限验证：通过token获取用户对应的 权限，动态根据用户的 权限算出其对应有权限的路由，通过router.addRoutes 动态挂载这些路由。
```

#### 70.购物车实现原理

#### 71.ref  toref  torefs

```js
* ref创建一个响应式数据，修改该数据的时候不会更改原数据，ref相当于拷贝

 * toRef创建响应式数据，修改会影响原数据，通过toRef创建的数据更细不会触发ui更新,toRef本质是引用，与原始数据有管理

 * toRef接受两个参数，第一个参数是哪个对象，第二个参数是对象的哪个属性

 * toRefs可以既与原数据进行关联，又可以更新ui视图

 * toRefs接受一个对象，用于批量设置多个数据为响应式数据，它会遍历对象身上的所有属性，然后挨个调用toRef执行

```

#### 72.回流重绘

```js
重绘: 当页面中元素样式的改变并不影响它在文档流中的位置时，也就是说布局没有发生改变时(比如只是改变元素的颜色)。简单来说就是改变css样式就会发生重绘
回流：当渲染树(Render Tree)中的部分（或全部）元素的尺寸、结构、显示隐藏等发生改变时，浏览器重新渲染的过程称为回流。 简而言之，任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。 回流是影响浏览器性能的关键 因素。
比如：
（1）添加或者删除可见的 DOM 元素(不可见元素不会触发回流)；
（2）元素尺寸或位置发生改变
（3）元素内容变化，比如文字数量或图片大小
（4）浏览器窗口大小发生改变
（5）CSS伪类的激活（例如：:hover，从而改变了元素的布局的）
注意：
回流必定会发生重绘，重绘不一定会引发回流。
回流比重绘的代价要更高。有时即使仅仅回流一个单一的元素，它的父元素以及任何跟它相关的元素也会产生回流，牵一发动全身。
```

#### 73. 宏任务和微任务

```css
宏任务
宏任务指执行栈中待执行的任务，计时器，事件回调，http回调都是宏任务。

微任务
微任务指执行栈清空后立即执行的任务（VIP通道，贵族就是不一样~），Promise 和 MutationObserver都是微任务。






宏任务（Macro Task）通常指的是一些较大的任务单元，它们需要较长的时间来执行，会阻塞主线程的执行。例如，setTimeout、setInterval等异步操作就是宏任务，它们会被添加到任务队列中，在主线程空闲时执行。

微任务（Micro Task）是一些较小的任务单元，它们需要较短的时间来执行，不会阻塞主线程。例如，Promise的then、catch、finally方法、MutationObserver等都是微任务，它们会在宏任务执行完毕后立即执行。

任务调度时，JavaScript引擎首先会执行当前执行栈中的同步任务，然后检查微任务队列，依次执行其中的微任务，直到微任务队列为空。接着，JavaScript引擎会选择宏任务队列中的第一个任务，执行该宏任务，并重新开始循环，执行下一个微任务和宏任务，依次类推。

这种任务调度模型使得在异步编程中，可以更好地控制任务的执行顺序和优先级。通常情况下，微任务比宏任务具有更高的优先级，因此会在下一个宏任务之前优先执行。

总结来说，微任务是在当前宏任务执行完成后立即执行的任务，而宏任务是需要进入任务队列，等待主线程空闲时才能执行的任务。这种任务调度机制能够提高 JavaScript 引擎的执行效率和用户体验。
```

#### 74.BFC(块级上下文)

```js
BFC 全称：Block Formatting Context， 名为 “块级格式化上下文”。

W3C官方解释为：BFC它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，Block Formatting Context提供了一个环境，HTML在这个环境中按照一定的规则进行布局。

简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用BFC呢，BFC可以看做是一个CSS元素属性

怎样触发BFC
这里简单列举几个触发BFC使用的CSS属性

overflow: hidden
display: inline-block
position: absolute
position: fixed
display: table-cell
display: flex

BFC的规则
BFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列
BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签
垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的标签外边距会发生重叠
计算BFC的高度时，浮动元素也参与计算

```

#### 75.栈和堆区别

```js




```

#### 76.js数据类型

| 数据类型           | 解释                                                         |
| ------------------ | ------------------------------------------------------------ |
| undefined          | var age;<br/>变量age没有初始值，将被赋予undefined【基本数据类型】 |
| null               | 表示一个空值，与undefined值相等【对象】                      |
| number             | var score=90;      //整数<br/>var score=96.5;   //浮点数  带小数点 浮点类型 |
| boolean            | 布尔型：true和false                                          |
| string             | 被引号（单引号或双引号）括起来的文本<br/>var string1="老陈你真帅"; |
| 引用数据类型object | 属性的集合、每个属性都由‘名/值’对构成<br/>{<br/>name:'老陈'，<br/>age:18<br/>} |
| Symbol             | 返回一个唯一的值                                             |



`Undefined`和`Null`虽然是两种不同的基本数据类型，但是在某些情况也存在相同之处，下面看一下它们两者相同点和不同点。

**（1）相同点**

第一：`Undefined`和`Null`两种数据类型都只有一个字面值，分别是`undefined`和`null`.

第二：`Undefined`和`Null`类型在转换为`Boolean`类型的值时，都会转换为`false`.

```js
 // var num;
    var num = null;
    var bool = Boolean(num);

    console.log(bool);//false
    console.log(typeof bool);//boolean
```

第三：在需要将两者转换成对象的时候，都会抛出一个`TypeError`的异常。

```javascript
var a;
var b=null;

cosnole.log(a.name);//Cannot read property 'name' of undefined

cosnole.log(b.name);//Cannot read property 'name' of undefined
```

第四：`Undefined`类型派生自`Null`类型，所以在非严格相等的比较下，两者是相等的。如下面代码所示：

```javascript
    var num1;
    var num = null;
    console.log(num1 == num); //true
```



**(2)不同点**

第一：`null`是`JavaScript`的关键字，而`undefined`是`JavaScript`的一个全局变量，也就是挂载在`window`对象上的一个变量，并不是关键字。

第二：在使用`typeof`运算符进行检测时，`Undefined`类型的值会返回`undefined`.而`Null`类型的值返回为`object`

```javascript
typeof undefined ;//undefined 



typeof null ;//object
```

第三：在需要进行字符串类型的转换时，`null`会转换成字符串`null`,而`undefined`会转换字符串`undefined`.

```javascript
undefined+" abc" //"undefined abc" 



null+" abc" //"null abc"
```

第四：在进行数值类型的转换时，`undefined`会转换为`NaN`,无法参与计算，而`null`会转换为`0`,可以参与计算。

```javascript
 console.log(undefined - 0);//NaN
 console.log(null - 0);//0
```



第五：建议：无论在什么情况下都没有必要将一个变量显示的赋值为`undefined`。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为`null`.



#### 77. js的执行机制

```js
js是一个单线程的语言，把所有的任务分为了同步任务和异步任务，

在执行的时候首先判断js代码是同步还是异步,同步就进入主线程,异步就进入任务队列event queue。 

同步任务进入主线程后一直执行（从上往下）,直到主线程空闲时（表示同步任务执行完毕），此时才会去任务队列event queue中查看是否有可执行的异步任务,如果有就将任务队列中的异步任务推入主线程中进行执行。


问：js为什么需要异步?

答：如果JS中不存在异步,只能自上而下执行（js是单线程的语言）,万一上一行解析时间很长,那么下面的代码就会被阻塞。

对于用户而言,阻塞就意味着"卡死",这样就导致了很差的用户体验。 


问：js为什么是单线程?

答：如果js的多线程，同时操作同一节点的删除修改时发生冲突


问： 异步任务有哪些呢？ 

答：定时函数setTimeout和setInterval; DOM事件绑定; Ajax操作; NodeJS中的fs文件读写 等。

```

#### 78.数组去重

```js
1.双重for循环结合splice
 var arr = [1, 2, 2, 2, 3, 3, 4, 5];
    console.log(arr);
    // 比较的数字
    for (var i = 0; i < arr.length; i++) {
        // 被比较
        for (var j = i + 1; j < arr.length; j++) {
            if (arr[i] == arr[j]) {
                arr.splice(j, 1);
                j--;
            }
        }
    }

    console.log(arr);

2.ES6 set方法
```



#### 79.v-if 和v-show的区别

```js
v-if条件不满足，整个dom节点都删除

v-show条件不满足，是通过display：none隐藏
```



#### 80.computed中的属性名和data中的属性名可以相同吗?

```js
在 Vue 的 computed 计算属性中，属性名不能与 data 数据中的属性名相同。

这是因为 Vue 对属性名的冲突进行了检测和保护，以确保计算属性的正确性和避免潜在的问题。
当你在 computed 中定义了一个与 data 中的属性同名的计算属性时，Vue 会抛出一个警告，并且会优先使用 data 中的属性值，而不是计算属性的返回值。
```



#### 81.css的权重

```js
  ！important                           至高的           
   内联样式                                   1000
   id选择器                                     100
   类选择器、伪类选择器                           10
   元素选择器                                    1
   通配选择器、关系选择器                          0

   继承选择器                             没有权重 
```



#### 82.require和import区别

```js
1.require 是赋值过程并且是运行时才执行， import 是解构过程并且是编译时执行。
2.require的性能相对于import稍低，因为require是在运行时才引入模块并且还赋值给某个变量，而import只需要依据import中的接口在编译时引入指定模块所以性能稍高
```



#### 83.http和https的区别

```js
http的URL是以http://开头，而https的URL是以https://开头。
http是明文传输，安全性低，而https可以进行加密传输，身份认证。
http的标准端口是80，而https的标准端口是443。

1. 端口不一样，http协议用的是80端口，https协议用的是443端口。

2. http明文传输（基于TCP连接），https密文传输（建立在SSL握手协议）。

3. 由于https是密文传输，所以https相对来说比http更安全一些。

4. https页面加载相对较长，因为https握手阶段比较费时。

5. https协议需要证书（一对公钥和私钥），而且大部分证书都是收费的。
```



#### 84.vue定义全局的方法

```js
// 在main.js中定义全局方法
import Vue from 'vue';

Vue.prototype.$myMethod = function () {
  // 全局方法的实现逻辑
  console.log('我是全局方法！');
};

// 在组件中可以直接使用全局方法
export default {
  mounted() {
    this.$myMethod(); // 调用全局方法
  },
};

```



#### 85.[hash](https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020)与history的区别



```js
**1.**hash路由在地址栏URL上有#，而history路由没有会好看一点

**2.**我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）【hash模式，#后面的数据，不会请求发送给后台，history会】

**3.**hash路由支持低版本的浏览器，而history路由是HTML5新增的API。

**4.**hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。

**5.**history运用了浏览器的历史记录栈，之前有back,forward,go方法，之后在HTML5中新增了pushState（）和replaceState（）方法（需要特定浏览器的支持），它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。

**6.**第三种路由模式
abstract: 是vue路由中的第三种模式，本身是用来在不支持浏览器API的环境中，充当fallback，而不论是hash还是history模式都会对浏览器上的url产生作用，本文要实现的功能就是在已存在的路由页面中内嵌其他的路由页面，而保持在浏览器当中依旧显示当前页面的路由path，这就利用到了abstract这种与浏览器分离的路由模式。
```

#### 86.强缓存和协商缓存

```js
强缓存:强缓存通过响应头cache-control中max-age等指令进行控制，max-age可设置强缓存时间周期，在该周期内可以直接从客户端缓存获取资源，而不会向服务器发送请求

协商缓存:通过响应头etag 与last-modified进行控制每次发送请求时，需要进行新鲜度校验，如果资源过旧，将直接从响应中获取，或者从客户端缓存中获取，
```

#### 87.如何实现一个拖拽功能

```js
1.在html中写一个div ,给这个div一个 position: absolute;
2.通过document.getElementsByTagName('div')[0]找到这个div
3.给这个div添加一个事件 onmousedown  (按下鼠标时) 通过函数中参数e访问到window顶层对象,在window中拿取到offsetX  offsetY 
4.然后再给dom元素添加事件onmousemove(鼠标移动时),也是通过函数中参数e获取window顶层对象,在window中拿取到clientX clientY
减去offsetX  offsetY 再使用js给div设置样式的left和top接收clientX clientY减去offsetX  offsetY
5.最后停下的时候再次给div一个事件onmouseup,在onmouseup的函数中把onmousemove赋值为null就可以了

<script>
    var div = document.getElementsByTagName('div')[0];
    //鼠标按下事件  获取xy轴的距离
    div.onmousedown = function(e){
        e = e|| window.event;
        // x y 值为鼠标点击位置距离点击元素的距离
        var x = e.offsetX;
        var y = e.offsetY;
        console.log(x,y);

        //鼠标移动事件  获取移动时距离浏览器页面的距离
        // 这个时间发生在整个文档中  要给文档添加时间
        document.onmousemove = function(e){
            e = e|| window.event;
            div.style.left = (e.clientX - x)+'px';
            // console.log();
            div.style.top = (e.clientY-y)+'px';
        }
    }

    div.onmouseup = function(){
        document.onmousemove = null;
    }
</script>
```



#### 88.em和rem的区别

```js
1、em相对于父元素的fon-size值进行变化的；rem是相对根节点html发生变化的（和父节点无关）
2、em是相对于当前元素或父元素进行换算，层级越深，换算越复杂;而rem是相对于根元素计算，避免层级关系。
   rem不仅可以设置字体的大小，还支持元素宽、高等属性。
```

#### 89.数据比较庞大的时候是怎么处理的

```js
1.vuex
2.混入(mixin)
```

#### 90.promise与setimeout谁先执行，为什么？

```js
在正常情况下，setTimeout先执行，然后是Promise。

原因是，当执行到setTimeout时，会将其回调函数推入到宏任务队列中，然后继续执行后续的代码。而Promise是微任务，当执行到Promise时，会将其回调函数推入到微任务队列中。

在当前宏任务执行完毕后，会检查微任务队列，如果存在微任务，则按照队列的顺序依次执行。因此，setTimeout的回调函数会在Promise的回调函数之前执行。

需要注意的是，在某些情况下，当Promise的状态已经是已解决（fulfilled）或已拒绝（rejected）时，它的回调函数会立即被放入微任务队列，并在当前宏任务结束前执行。这可能导致Promise的回调函数在setTimeout的回调函数之前执行。
```

#### 91.token值存储在哪里？有存储到vuex里面的情况吗以及怎么存储？

```js
Token 值可以存储在多个地方，常见的包括浏览器的本地存储（例如 localStorage 或 sessionStorage）、HTTP 的 cookie、HTTP 请求的头部以及后端的数据库中。

在使用 Vuex 管理状态的情况下，你可以选择将 Token 值存储在 Vuex 的 state 中。

1、在 Vuex 的 state 中定义一个属性来存储 Token 值

2、然后，在 Vuex 的 mutation 中定义一个方法来更新 Token 的值

3、接下来，在需要存储 Token 值的地方（例如登录成功后），使用该 mutation 方法来更新 Token 的值

4、最后，在需要获取 Token 值的地方，可以通过 Vuex 的 getter 来获取
```

#### 92.你的后台管理系统是怎么上传本地文件？

```js
需要使用到element-plus中的文件上传功能。

富文本编辑器等    
```

#### 93.怎么优化代码？提高网页加载速度？

```js
1、 加载优化（减少http请求数）；
2、使用图片懒加载技术；
3、路由懒加载
4、尽可能的使用webp格式的图片，精灵图（雪碧图）；
5、样式、行为、结构分离
6、HTML结构要清晰，尽可能使用语义化标签
7、将样式表放在头部,脚本放在底部
8、使用CDN技术。
9、开启Gzip（代码压缩）
10、尽量使用使用轻量级框架
11、避免img,src等标签的src属性为空，空src会重新加载当前页面，影响速度和效率。
12、减少不必要的Cookie

Cookie存储在客户端，伴随着HTTP请求在浏览器和服务器之间传递，由于cookie在访问对应域名下的资源时都会通过HTTP请求发送到服务器，从而会影响加载速度，所以尽量减少不必要的Cookie。
```

#### 94.状态码302怎么处理？

```
路由重定向

自动重定向：大多数浏览器会自动处理302，并跳转到Location指定的URL。这是最常见的处理方式，无需额外编码。
​
手动处理：如果你需要在代码中进行处理，你可以使用编程语言提供的函数或库来实现手动重定向。具体实现方式取决于你使用的编程语言和框架
```



#### 95.Vue中如何动态设置未在data里声明的变量为响应式？ 

```js
在Vue中，只有在data对象中声明的属性才会被Vue实例追踪并成为响应式的。如果想要动态添加一个未在data中声明的变量，并且希望它也能成为响应式的，你可以使用Vue.set方法或者this.$set方法来实现。
this.$set(目标对象, 属性名/索引， 新值)
```

#### 96.小程序上线问题，app上线问题，vue打包问题

```js

```



#### 97.从a页面跳转到b页面，点击浏览器的回退按钮，分别触发什么周期函数？

```

```



#### 98.简单介绍工厂模式

```js
工厂模式

软件工程领域的一种设计模式
抽象了创建对象的过程
通过函数封装创建对象的细节，就是把创建对象的过程封装在了函数中



大白话：

>毕业两年，码农张小两口无法忍受挤公交，凌晨起床抢火车票的痛苦，遂计划买车。逛了多家4S店，最终定下本田飞度车型的轿车。4S店接受订单后，向工厂说明车型，工厂随后进行汽车制造，运输到4S店中再到了小两口的手上，小两口终于成了有车一族。
>
>4S销售模式即为典型的简单工厂模式。

> 工厂模式的要点在于：**当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节**。
```

#### 99.vue定义全局的方法

```js
// 在main.js中定义全局方法
import Vue from 'vue';

Vue.prototype.$myMethod = function () {
  // 全局方法的实现逻辑
  console.log('我是全局方法！');
};

// 在组件中可以直接使用全局方法
export default {
  mounted() {
    this.$myMethod(); // 调用全局方法
  },
};

```

#### 100.ES6的解构赋值是深拷贝还是浅拷贝

```js
ES6的解构赋值是浅拷贝。
解构赋值是一种从数组或对象中提取值并赋给变量的语法，它创建了对原始数据的浅拷贝。浅拷贝意味着被赋值的变量只是原始数据的引用，而不是副本。因此，如果原始数据发生变化，被赋值的变量也会随之改变。若需要进行深拷贝，可以使用其他方法，比如使用扩展运算符或者写一个自定义的深拷贝函数。
```

#### 101.promise与setimeout谁先执行，为什么?

```js
在正常情况下，setTimeout先执行，然后是Promise。

原因是，当执行到setTimeout时，会将其回调函数推入到宏任务队列中，然后继续执行后续的代码。而Promise是微任务，当执行到Promise时，会将其回调函数推入到微任务队列中。

在当前宏任务执行完毕后，会检查微任务队列，如果存在微任务，则按照队列的顺序依次执行。因此，setTimeout的回调函数会在Promise的回调函数之前执行。

需要注意的是，在某些情况下，当Promise的状态已经是已解决（fulfilled）或已拒绝（rejected）时，它的回调函数会立即被放入微任务队列，并在当前宏任务结束前执行。这可能导致Promise的回调函数在setTimeout的回调函数之前执行。
```



#### 102.模块化开发的好处

```js
1.提高了代码的复用性
2.提高了代码的可维护性
3.可以实现按需加载
4.防止变量污染
```

#### 103.水平垂直的方法

```js
行内元素  （文本的水平垂直居中）

​    单行文本 text-align:center   固定高： line-height:高度

​                                无高： padding:30px 0;


​    多行文本  text-align:center  无高：padding:30px 0;

​                              固定高：display:table-cell

​                                    vertical-align: middle


块级元素：

​        固定高：  margin:  (父级元素的高-当前元素的高) /2  auto;

​      无固定高：  margin:auto

​                padding: 30px 0;


定位 和 位移：

​            需要水平垂直居中的元素  ： position:absolute

​            top:50%;

​            left:50%;

​            transform:translate(-50%,-50%)

​            父元素：position:relative

      
弹性布局：

​         需要水平垂直居中的父元素： display:flex;

​                               justify-content: center;

​                               align-items: center;
```

#### 104.如何阻止默认事件?

```js
 window.event? e.returnValue = false :e.preventDefault();
使用event.preventDefault()：在事件处理程序中调用event.preventDefault()方法可以阻止事件的默认行为。例如，在点击链接时，可以在点击事件处理程序中使用event.preventDefault()来阻止页面跳转。
```

#### 105.后台管理中如何实现页面级的按钮权限

```js

主要方式是在el-button按钮上设置标签数值，利用vue的自定义指令功能获取按钮实例对象和按钮上绑定的标签数值，与从接口拿到的按钮权限列表进行匹配，如果匹配成功，证明用户拥有该按钮的使用权限，如果发现没有使用权限，则在指令处理函数中编写代码移除该按钮，界面上就看不到该按钮了。

1、当用户登录后返回的权限中有对应权限的数据为布尔值，存储到vuex中
2、创建一个全局的自定义指令 directive
3、在按钮上面写入自定义指令
4、把该用户相应权限写到自定义指令的表达式中
5、创建自定义指令中判断bindings.value
6、当bindings.value的值为false时，通过el.parentNode.removeChild(el)删除改按钮 反之保留	
```

#### 106.qs.stringfy和json.stringfy的区别

```js
qs是一个npm仓库所管理的包，可通过npm install qs命令进行安装。
qs.stringify()将对象序列化成URL的形式，以&进行拼接。
qs.parse()将URL解析成对象的形式 。
JSON.stringify()是正常类型的JSON。
```

#### 107.\_proto_ 和 prototype 区别

```js
1.prototype是函数独有的，而_proto_是每个对象都会拥有的(包括函数)
2.prototype的作用是保存所有实例公共的属性和方法;_proto_的作用是当访问一个对象的属性时,如果内部没有该属性,就会在它_proto_属性所指的那个父对象去找,父对象没有,再去父对象的父对象里找…直到null,即原型链.
3.s.proto === Student.prototype
prototype还有一个constractor属性,指向该对象的构造函数本身.
```

#### 108.this.$set为什么监听不到数组的长度变化

```js

```

#### 109.webpack的打包流程

```js
1、从入口(entry) 开始，递归转换入口文件所依赖的module

2、每找到一个module，就根据对应的loader去转换这个module

3、然后，再对当前module依赖的所有module进行转换，如果子module还有依赖的话，再转换，直至没有依赖

4、其次，以入口文件(entry)为单位进行分组，一个entry和其所有依赖的module被分到一个块(Chunk)。

5、最后，Webpack会把所有Chunk转换成文件输出，在整个流程中Webpack会在恰当的时机执行plugin里定义的扩展插件。
```



#### 110.splice与slice有什么区别

```js
slice()：按照条件查找出其中的部分内容

参数：
array.slice(n, m)，从索引n开始查找到m处（不包含m）
array.slice(n) 第二个参数省略，则一直查找到末尾
array.slice(0)原样输出内容，可以实现数组克隆

返回值：返回一个新数组

是否改变原数组：不改变

splice()：对数组进行增删改

增加：ary.splice(n,0,m)从索引n开始删除0项，把m或者更多的内容插入到索引n的前面，返回空数组

修改：ary.splice(n,x,m)从索引n开始删除x个，m替换删除的部分，把原有内容删除掉，然后用新内容替换掉

删除：ary.splice(n,m) 从索引n开始删除m个内容，（如果第二个参数省略，则从n删除到末尾）

返回删除的新数组，原有数组改变
```



#### 111.js的作用域链是什么

```js
一般情况下，变量取值是到创建这个变量的函数的作用域中取值。

但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域

这么一个查找过程形成的链条就叫做作用域链	
```

#### 112.display和overflow: hidden有什么区别

```javascript
display：none隐藏标签不占实际位置 overflow：hidden 隐藏元素占用实际位置
```

#### 113.html5新增那些标签

```js
1、新增语义化标签

主要是针对搜索引擎的，可以使用多次，在IE9中需要将这些标签转换成块级元素，移动端更喜欢用。

header头部标签

nav导航栏标签

article内容标签

section定义文档某个区域

aside侧边栏标签

footer尾部标签

以前这些标签都用div来做，但是div对浏览器来说没有语义。

2、新增视频音频标签

video视频

autoplay自动播放 谷歌要加muted

controls播放控件

loop循环播放

poster=""在视频没加载完前显示一张图片

audio

muted音频静音

和vedio类似

3、新增Input表单

验证的时候要有form表单，提交时就会验证。

email邮箱

url网址

date日期

number数量

tel电话号码

search搜索

color颜色

4、新增表单属性

required="required" 表单中不能为空

placeholder提示文本 也可以在样式中改变颜色 input::placeholder{}

autofocus自动获得焦点 比如打开百度，光标自动就定在了搜索框

autocomplete基于之前键入的值，显示，默认打开on,一般设为关闭off

multiple可以多选文件提交
```

#### 114.css3的2D3D

```
2D

属性：transform

 移动：translate()  旋转：rotate()   缩放：scale()   倾斜：skew()

3D

移动translate3d(x,y,z)      旋转rotate3d(x,y,z,angle[角度])   

 缩放scale3d(x,y,z)
```

| 属性                | 说明                                           |
| ------------------- | ---------------------------------------------- |
| transform           | 2D或3D转换                                     |
| transform-origin    | 改变旋转点位置                                 |
| **transform-style** | 嵌套元素在3D空间如何显示 是否是3d效果 取决于他 |
| perspective         | 规定3D元素的透视效果 视距                      |
| perspective-origin  | 规定3D元素的底部位置 视角                      |



#### 115.如何改变this指向

```js
1、call方法
2、apply方法
3、bind方法


call、apply、bind相同点以及不同点
（1）相同点：
都可以改变函数内部的this指向
（2）区别：

call和apply会调用函数，并且改变函数的内部的this指向；

call和apply参数参数的方式是不一样的，call参数是以罗列的方式传递，apply参数是以数组的方式传递；

bind不会调用函数，可以改变函数内部this指向；
```

#### 116.在请求拦截器中都做了那些事情

```js
在挂载在原型对象之前设置一个请求拦截器
// interceptors  in特赛布特斯
axios.interceptors.request.use(config => {
  //console.log(config); //config 中有 headers请求头   
  // 挂载了一个Authorization（奥泽ruai忒申）一个请求头   在每次请求的时候Authorization中就会携带token值 这样服务器就会通过此次请求
  config.headers.Authorization = window.sessionStorage.getItem('token')
  return config
})
```

#### 117.讲一下内存泄漏和垃圾回收机制

```
1,不再用到的内存，没有及时释放，就叫做内存泄漏

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

2,垃圾回收机制

最常使用的方法叫做"引用计数"    如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。

例如

let arr = [1, 2, 3, 4];

 console.log('hello world'); 

arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0,  就完成了垃圾回收

3.内存泄漏的识别方法

> 经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。
```



#### 118.null和undefined的区别

`Undefined`和`Null`虽然是两种不同的基本数据类型，但是在某些情况也存在相同之处，下面看一下它们两者相同点和不同点。

**（1）相同点**

第一：`Undefined`和`Null`两种数据类型都只有一个字面值，分别是`undefined`和`null`.

第二：`Undefined`和`Null`类型在转换为`Boolean`类型的值时，都会转换为`false`.

```js
 // var num;
    var num = null;
    var bool = Boolean(num);

    console.log(bool);//false
    console.log(typeof bool);//boolean
```

第三：在需要将两者转换成对象的时候，都会抛出一个`TypeError`的异常。

```javascript
var a;



var b=null;

cosnole.log(a.name);//Cannot read property 'name' of undefined

cosnole.log(b.name);//Cannot read property 'name' of undefined
```

第四：`Undefined`类型派生自`Null`类型，所以在非严格相等的比较下，两者是相等的。如下面代码所示：

```javascript
    var num1;
    var num = null;
    console.log(num1 == num); //true
```



**(2)不同点**

第一：`null`是`JavaScript`的关键字，而`undefined`是`JavaScript`的一个全局变量，也就是挂载在`window`对象上的一个变量，并不是关键字。

第二：在使用`typeof`运算符进行检测时，`Undefined`类型的值会返回`undefined`.而`Null`类型的值返回为`object`

```javascript
typeof undefined ;//undefined 



typeof null ;//object
```

第三：在需要进行字符串类型的转换时，`null`会转换成字符串`null`,而`undefined`会转换字符串`undefined`.

```javascript
undefined+" abc" //"undefined abc" 



null+" abc" //"null abc"
```

第四：在进行数值类型的转换时，`undefined`会转换为`NaN`,无法参与计算，而`null`会转换为`0`,可以参与计算。

```javascript
 console.log(undefined - 0);//NaN
 console.log(null - 0);//0
```



第五：建议：无论在什么情况下都没有必要将一个变量显示的赋值为`undefined`。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为`null`.



#### 119.vue2如何检测数组变化

```js
1.this.$set
```

#### 120.axios的原理

```js
axios是一个基于Promise的方法，可以发送get、post等请求，并且前后端都可以使用。

1.axios库对外暴露了一个axios实例，axios实例其中挂载了一个Axios方法，Axios方法有一个interceptors对象(拦截器)，interceptors对象有request对象和response对象，并且request对象和response对象都有use方法，所以，我们可以调用axios.interceptors.request.use()和axios.interceptors.response.use().

2.interceptors对象里面的request对象和response对象其实是一个用来管理拦截器的数组（handlers）。当我们调用axios.interceptors.request.use()，就会在request的拦截器数组（handlers）里面push一个成功回调和一个失败回调。每使用一次，就push一次，类似[res1,rej1,res2, rej2…]

3.接下来是一个chain，它是一个存储所有回调的数组，因为它是给Promise使用的，所以它需要使用两个值，初始值为dispatchRequest和undefiend。接着，Promise.resolve(config).then(fn1, fn2)。当config里面的结果为fulfilled(成功），就把config里的配置传给fn1并执行。如果为reject(报错)，就把错误结果传给fn2并执行.即Promise.resolve(config).then(chain[0], chain[1])。chain[0]为成功回调，chain[1]为失败回调。config里面有很多配置项，他们可能是一个string值或方法等。

4.接下来是整理所有的Promise,把request数组里的回调函数unshift到chain数组的最前面，把response数组里的回调函数push到chain数组的最后面。最终chain数组里面类似[res2, rej2,res1, rej1, dispatchRequest,undefiend,res3, rej3, res4, rej4]。

5.dispatchRequest是用来执行axios.request的，dispatchRequest方法里面有一个adapter,它会根据不同的环境调用不同的对象。如果是在浏览器环境下，调用XMLHttpRequest对象。如果是nodejs环境下，就调用http对象。这就是为什么它既能在前端使用，也能在后端使用的原因。adapter会对请求到的数据进行解析封装，封装后的对象就是我们能看到的response响应对象。

6.处理完dispatchRequest，就会执行interceptors.response的回调函数。这就是为什么我们看到的执行顺序是，后者的interceptors.request比前者的interceptors.requets先执行，接着执行axios.request,最后顺序执行interceptors.response.

7.接下来执行我们的业务逻辑。


```

#### 121.vue3中的proxy都有那些参数

```js
两个 
第一个参数是所要代理的目标对象,第二个参数是处理程序对象。他下面有三个方法：
get(target, property, receiver)：
拦截对目标对象属性的读取操作。

set(target, property, value, receiver)：
拦截对目标对象属性的设置操作。

apply(target, thisArg, argumentsList)：
拦截对目标对象作为函数调用的操作。
```

#### 122.vue2和vue3的传值有什么区别



```
在Vue 2中，父组件通过Props属性将数据传递给子组件。子组件通过接收Props来获取传递的数据。 
事件：子组件可以通过$emit触发一个自定义事件，并将数据传递给父组件。

在Vue 3中，Props的用法与Vue 2基本一致，但可以通过setup函数更方便地获取和处理Props。
事件：可以使用emits选项来声明要在子组件中触发的事件，使得事件更加明确和类型安全。

总的来说，Vue 3中引入了Composition API，使得组件的传值更加灵活和直观。通过setup函数和defineProps、defineEmits等API，可以更方便地处理Props和自定义事件，让组件之间的传值更加清晰、易于维护。而Vue 2中传值的方式也仍然有效，可以继续使用
```



#### 123.项目的开发流程

 

#### 124.怎么解决get缓存

```js
HTTP get请求通常是获取数据，一般看到get的话就是从后台拿数据前端展示使用

但是在get请求的时候，不同的浏览器会出现不同的情况：

请求数据有时候是304，有时候是200

出现这种情况一般是缓存的问题，因为get请求基本就是获取数据，get的时候为了节省时间和空间就直接走缓存，以便于再次请求访问

解决办法：
一般是在get请求后面添加一些随机数，比如说时间戳；这样每次请求都会当做新的请求去访问后台。
禁用缓存：可以在发送GET请求时，在请求头中加入相关字段来告知浏览器不要缓存该请求。

也可以在服务端（后端）设置响应头，在后端服务器中，可以设置响应头，告知浏览器不要缓存该响应

```

#### 125.在url输入之后到页面展示发生了什么

```js
1.URL解析：浏览器会解析用户输入的URL，并将其分解成协议、主机名、端口号、路径和查询参数等部分。
2.DNS解析：如果URL中包含了域名（主机名），浏览器会进行DNS解析，将域名解析为对应的IP地址。这是为了在Internet上找到正确的服务器。
3.建立TCP连接：浏览器通过解析得到的IP地址和端口号，与Web服务器建立TCP连接。TCP连接是一种可靠的传输协议，用于在客户端和服务器之间传输数据。
4.发送HTTP请求：一旦TCP连接建立成功，浏览器会向服务器发送HTTP请求。
5.服务器处理请求
6.接收响应数据：浏览器接收到服务器返回的HTTP响应数据
7.渲染页面：浏览器根据收到的响应数据，开始解析HTML、CSS和JavaScript代码，构建DOM树、CSSOM树，并执行JavaScript代码来完成页面的渲染和交互。
8.展示页面
```

#### 126.git命令

```js
> ——横线之前是命令
>
> ——横线之后是解释说明

1.新建文件夹，上方文件地址栏输入cmd，打开命令行
2.git init——初始化一个本地仓库
3.git remote add origin git项目地址——本地仓库关联远程仓库（用http方式就行，ssh的话提前配置密钥）
4.git fetch origin master——关联远程master分支
5.git branch -r——查看远程仓库的所有分支

> 以上项目代码就已经克隆下来了，并且关联了远程仓库，同步了所有分支，下面创建我们自己的分支

6.git branch——查看本地的所有分支，绿色的字代表自己现在所在的分支
7.git checkout master——切换到master分支上
8.git checkout -b xxx——创建并切换到xxx分支上（xxx是你自定义的分支名）
9.git push -u origin xxx——将自己的xxx分支推至远程仓库（第一次推加-u参数，后续再推就不用加了，推的时候自己要在当前的xxx分           支上）
10.git status——查看当前状态，在哪个分支上，更改了那些文件
11.git add .——将更改的文件内容添加到暂存区（注意不要少打这个.）
12.git commit -m '备注更改内容'——提交到本地仓库
13.git push origin xxx——推送至远程的xxx分支（第一次提交加-u参数）

> 以上创建了自己的分支，更改内容，并提交到了远程仓库，下面同步测试分支

14.git checkout master----切换至master分支
15.git checkout -b dev origin/dev——创建并切换到dev分支，并且同步远程的dev分支
16.git pull origin dev——合并之前，现将远程的dev拉下来一下，以免有其他人推送过新功能
17.git merge xxx——合并xxx分支代码（注意：要往哪个分支上合并，就先切换到哪个分支上）
18.git push origin dev——推送到远程的dev分支

> 同理：推送到master分支

19.git checkout master——切换至master分支
20.git pull origin master——拉下远程master分支的新代码
21.git merge xxx——将自己的xxx分支合并到master
22.git push origin master——推送至远程master

> 拉取别人分支
> 如果要拉取别人的分支，但git branch -r 发现远程并没有别人的这个分支

23.git remote update origin --prune——同步远程仓库的所有分支，这样可以拉别人的分支一起开发

> 最后：删除自己的本地分支和删除远程仓库的分支（要删除哪个分支，当前就不能在这个分支上）

git branch -d xxx——删除本地的xxx分支,该分支没有任何未提交的内容
git branch -D xxx——删除本地的xxx分支,该分支存在未提交的内容，强制删除
git push origin --delete xxx——删除远程仓库的xxx分支
```



#### 127.ts解决了那些js问题

```
1.静态类型检查：JavaScript是一种动态类型语言，类型错误在运行时才能被发现，这可能导致难以调试和维护的问题。TypeScript通过引入静态类型检查，允许开发人员在编码期间捕获许多常见的错误，并提供更好的开发时工具支持。
2.强大的面向对象编程支持：JavaScript是一种基于原型的语言，而不是传统的面向对象语言。TypeScript在JavaScript的基础上添加了类、接口、继承、泛型等面向对象编程的概念和特性，使得代码组织和维护更加容易。
3.更好的可读性和可维护性：TypeScript具有更丰富的类型系统和强大的编辑器支持，可以提高代码的可读性和可维护性。静态类型检查可以帮助开发人员更好地理解代码的意图，并在开发过程中提供更准确的自动完成、重构和错误提示。
4.渐进式开发：TypeScript是JavaScript的超集，这意味着现有的JavaScript代码可以无缝地迁移到TypeScript中，并逐步引入类型检查和其他特性，而无需进行全面的重写。这使得团队可以以渐进的方式采用TypeScript，减少了学习成本和项目迁移的风险。

总的来说，TypeScript提供了更好的工具和语言特性，在大型项目中可以提高代码的质量、可维护性和可扩展性，并减少潜在的错误。
```

#### 128.什么是回调地狱

```
层层嵌套，当上一次请求成功以后，才能进行下一次的数据请求，过程不受控制（接口数据嵌套）
一个异步请求套着一个异步请求，一个异步请求依赖于另一个的执行结果，使用回调的方式相互嵌套。
```

#### 129.object.is与==和===的区别

```
Object.is()与==运算不同之处在于==需要做类型转化，但是Object.is()不需要做类型转化。
Object.is()与===运算不同之处在于，在===下，+0和-0相同，NaN和NaN不同，在Object.is()下,+0和-0不相同，NaN和NaN相同。
```

#### 130.重写和重载

```
重写：保留父类的方法名，但是方法的实现内容或成员的返回值类型都被子类更改。
重载：是在一个类中,方法名字相同,参数不同.返回类型可以相同也可以不同
```

#### 131.  ？.

```
比如说判断对象的某个属性是否存在，如果存在那么就返回整个属性的值，否则返回undefined
```

#### 132.||与？？的区别

```
使用 ?? 时，只有当值1为null或undefined时才返回值2
使用 || 时，值1会转换为布尔值判断，为true返回值1，false 返回值2
```

#### 133. any与unknown区别

```
any : 动态的变量类型(失去了类型检查的作用)。
unknown: 任何类型的值都可以赋给 unknown 类型，但是 unknown类型的值只能赋给 unknown 本身 和 any 类型。
绝大多数情况使用unknown代替any更好的约束类型
```

<hr>

##### 134、频繁操作dom，怎么减少浏览器的消耗

频繁操作 DOM 可能会导致性能下降、浏览器消耗增加，因此可以考虑以下几种方法来减少对浏览器的消耗：

1. 批量操作：将多个 DOM 操作合并为一次操作，减少 DOM 访问和修改的次数。例如，使用 DocumentFragment 对象将多个元素一次性添加到 DOM 中，或者使用字符串拼接方式来生成 HTML 内容，最后再一次性添加到 DOM。

2. 缓存 DOM 引用：在频繁操作的过程中，尽量避免多次访问相同的 DOM 元素。可以先将相应的 DOM 引用存储在变量中，然后反复使用该变量进行操作，避免多次查询 DOM 结构。

3. 使用事件委托：通过事件委托的方式将事件处理程序添加到共同的父元素上，而不是为每个子元素单独绑定事件。这样可以减少事件处理程序的数量，提高性能。

4. 避免频繁的样式更改：在需要修改元素样式的情况下，尽量使用 CSS 类名的方式进行样式切换，而不是直接操作元素的 style 属性。因为修改 style 属性会导致浏览器触发样式计算和重新渲染。

5. 使用虚拟 DOM 技术：一些框架如 React、Vue 等可以使用虚拟 DOM 技术来提高性能。虚拟 DOM 作为中间层，可以在内存中进行频繁的操作和修改，最后再一次性更新到真实的 DOM。

6. 使用合适的动画方法：在需要进行动画效果的情况下，尽量使用 CSS 动画或者使用 requestAnimationFrame 方法来实现动画效果，这些方法通常比直接修改 DOM 产生的动画效果更流畅

   <hr>

#### 135、vite和webpack的区别

Vite 和 webpack 是两种常用的前端构建工具，它们有一些关键的区别：

1. 构建原理：Vite 基于 ES 模块的原生浏览器支持，利用浏览器原生的模块解析能力，通过服务端构建的方式实现了快速的冷启动和模块热更新。而 webpack 则通过静态分析依赖，将所有资源打包成多个 bundle，在运行时动态加载和解析模块。
2. 构建速度：Vite 在开发环境下具有非常快的冷启动速度和热更新速度，几乎可以实现秒级的重新构建。而 webpack 在构建大型项目时可能会遇到较长的构建时间，尤其在首次构建时。
3. 开发体验：Vite 支持原生的 ES 模块引入和浏览器原生的模块解析，无需显式打包，可以直接运行源代码。它还内置了支持热模块替换 (HMR) 的开发服务器，使开发过程更加顺畅。webpack 则需要将所有源代码打包成 bundle，然后在浏览器中执行。
4. 插件生态：webpack 有着庞大的插件生态系统，可以为项目提供各种各样的功能扩展，如代码压缩、图片优化、代码拆分等。而 Vite 在设计上更加轻量，插件机制相对简单，生态系统相对较小，但它仍然提供了一些常用的插件和功能扩展。

总的来说，Vite 更适用于开发环境，提供快速的构建和热更新能力，以及更好的开发体验。而 webpack 则更适用于构建复杂的大型项目，提供了丰富的插件和功能，适应性更强。选择哪种工具取决于项目的需求和目标。

<hr>

#### 136、seo怎么做

SEO（Search Engine Optimization，搜索引擎优化）是一系列的技术和策略，旨在提高网站在搜索引擎中的可见性，从而增加有机（非付费）流量和提高网站的排名。下面是一些常见的 SEO 实践：

1. 关键词优化：研究并选择与你的网站和内容相关的关键词，在网页标题、元描述、标题标签、内容和 URL 中合理使用关键词。但要确保关键词的使用自然，避免过度优化。
2. 内容质量：撰写高质量、有价值的内容，满足用户需求。内容应该清晰易懂、结构良好、有足够的长度，并包含相关的图像、视频和链接等多媒体元素。
3. 网站结构优化：确保网站的结构清晰且易于导航，有良好的内部链接结构。确保每个页面都可以从其他页面访问，并且搜索引擎可以轻松索引和抓取网站内容。
4. 页面速度优化：优化网站的加载速度，包括压缩代码、优化图像、使用缓存和减少重定向等技术。快速加载的网站对于用户体验和搜索引擎排名都非常重要。
5. 移动友好性：确保网站在移动设备上能够良好展示，具备响应式设计或移动专用版本，并确保移动用户能够方便地浏览和使用网站。
6. 外部链接建设：与其他高质量、相关性强的网站建立良好的外部链接，增加网站的权威性和可信度。这可以通过内容营销、社交媒体推广、媒体关系等方式来实现。
7. 社交媒体整合：将网站与社交媒体平台整合起来，通过社交分享、社交媒体营销等方式增加网站的曝光度和流量。

需要注意的是，SEO 是一个长期而复杂的过程，需要不断监测和优化。同时，搜索引擎的算法和规则也在不断调整，因此要时刻关注最新的 SEO 趋势和技术。最重要的是，提供有价值、有用的内容给用户，符合用户期望是最基本的原则。

#### 137、封装promise

```js
function myPromise() {
  return new Promise((resolve, reject) => {
    // 执行异步操作

    // 异步操作成功的情况
    if (/* 异步操作成功的条件判断 */) {
      resolve('Promise resolved');
    }
    // 异步操作失败的情况
    else {
      reject(new Error('Promise rejected'));
    }
  });
}

// 调用封装的 Promise
myPromise()
  .then(data => {
    console.log(data); // 处理异步操作成功的情况
  })
  .catch(error => {
    console.error(error); // 处理异步操作失败的情况
  });
```

<hr>

#### 138、什么情况下使用Vuex

1. 多个组件共享状态：如果你的应用中多个组件需要共享同一状态（例如：用户登录状态、购物车内容、主题等），使用 Vuex 可以将这些共享状态集中管理，避免了组件间的状态传递和数据同步的问题。
2. 多个组件频繁、复杂地进行状态变更：如果你的应用中有一些复杂的业务逻辑需要频繁地进行状态变更、异步操作或者涉及到多个组件的响应，使用 Vuex 可以更好地管理这些状态变更和异步操作的逻辑，避免代码的重复和混乱。
3. 状态需要在不同的组件之间进行共享和访问：如果你需要在不同的组件中访问和修改同一份状态数据，使用 Vuex 可以提供统一的接口并保持状态的一致性，方便管理和修改。
4. 状态需要进行持久化或者本地缓存：如果你需要将状态数据进行持久化存储（如本地存储、cookie 等）或者在用户刷新页面后仍然保留修改前的状态，使用 Vuex 可以更方便地管理状态的持久性和缓存。

#### 139、js的异步事件

JavaScript 中的异步事件是指在代码执行过程中，某些操作不会立即执行，而是在将来的某个时间点执行的事件。常见的 JavaScript 异步事件包括：

1. 定时器：使用 setTimeout 或 setInterval 函数可以在指定的时间间隔后执行特定的代码。setTimeout 用于在一定的延迟后执行一次代码，而 setInterval 则会根据指定的时间间隔重复执行代码。
2. 回调函数：回调函数是一种常见的异步编程模式，当某个操作完成时，会调用预先定义的回调函数来处理结果或执行相关操作。例如在网络请求、文件加载等异步操作完成后执行回调函数来处理返回的结果。
3. 事件监听器：通过在 DOM 元素上添加事件监听器来响应特定的事件，例如鼠标点击、键盘按键等。当事件触发时，事先绑定的回调函数会被执行。
4. Promise：Promise 是一种用于处理异步操作的对象。它表示一个尚未完成但预计将来会完成的操作，并提供了链式调用的方式来处理操作的结果。
5. async/await：async/await 是 ES2017 引入的异步编程语法糖。通过使用 async 函数定义异步代码块，以及使用 await 关键字等待 Promise 对象的处理结果，使得异步代码的书写更加直观和顺序执行。

这些异步事件在 JavaScript 中的使用，可以让代码在等待异步操作完成期间继续执行其他任务，提高了程序的响应性和效率。同时，异步事件也能够避免阻塞主线程，保证了用户界面的流畅性和用户体验。

#### 140、如何SEO优化

前端 SEO（Search Engine Optimization，搜索引擎优化）是指通过前端技术和最佳实践来提升网页在搜索引擎中的排名和可见性。以下是一些前端 SEO 优化的方法：

1. 关键词研究和优化：进行关键词研究，了解用户可能会使用哪些关键词进行搜索，然后在页面的标题、元描述、 Heading 标签、正文内容等位置合理地使用关键词，但要注意避免过度堆砌关键词，以免被搜索引擎视为垃圾内容。
2. URL 结构优化：构建有意义的、简洁的 URL 结构，使用关键词相对应的 URL，避免使用过长的动态 URL，提高页面的可读性和搜索引擎的识别能力。
3. 内容优化：创建高质量、原创、有用的内容，提供独特且有价值的信息，吸引用户对页面进行访问并提高页面的时长和转化率。同时，使用标签（如 `<H1>`、`<H2>`、`<strong>` 等）来强调内容中的关键信息，帮助搜索引擎理解页面的结构和内容。
4. 网站结构优化：优化网站的结构，使其易于导航和索引。通过合理的内部链接，使搜索引擎能够轻松地跟踪和访问网站的各个页面。
5. 页面加载速度优化：优化页面的加载速度，减少文件的大小和数量，压缩和合并 CSS、JavaScript 文件，使用适当的图片压缩方法，使用缓存和 CDN 加速等技术，提高页面的加载速度。
6. 移动优化：确保网站在移动设备上能够良好显示，并且具备良好的响应式布局或移动端专用的布局，以满足移动设备用户的需求。
7. 代码质量优化：编写规范的、语义化的 HTML，使用合适的标签和属性，改进代码结构和性能，使页面更易于搜索引擎的理解和解析。
8. 合理使用标签：合理地使用标题标签（H1、H2等）和段落标签（P），以突出重要关键词和内容，并让搜索引擎更好地理解页面结构和主题。
9. 创建 XML SiteMap：创建 XML 格式的站点地图，将其提交给搜索引擎，以帮助搜索引擎更好地索引和理解网站的结构。
10. 社交分享和外部链接：鼓励用户进行社交分享，增加页面的外部链接，提升页面的被引用和分享度，以提高页面的可信度和排名。

值得注意的是，前端 SEO 优化仅仅是搜索引擎优化的一部分，还需要考虑后端优化、内容策略、用户体验等方面，综合提升网站的可见性和排名。同时，也要密切关注搜索引擎的更新和算法变化，及时调整优化策略。