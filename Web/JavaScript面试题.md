## 数组的方法

### 1.push() 末尾添加元素

```js
// 1.push  push方法可以向数组的末尾添加一个或者多个元素 返回新数组的长度 改变原数组.
  var arr = [1, 2, 3];
  var c = arr.push(5);
  console.log(arr);//[1, 2, 3, 5]
  console.log(c);//4  数组改变之后的长度
```

### 2.pop() 删除末尾元素

```js
 // 2.pop   pop() 方法用于删除并返回数组的最后一个元素 改变原数组。
  var arr = [1, 2, 3, 4, 5];
  var c = arr.pop();
  console.log(arr);//[1, 2, 3, 4];
  console.log(c);//5
```

### 3. unshift() 添加首位元素

```js
 // 3.unshift  unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度  改变原数组。
  var arr = [1, 2, 3, 4, 5];
  var c = arr.unshift(6);
  console.log(arr);//[6, 1, 2, 3, 4, 5]
  console.log(c);//6  数组改变之后的长度
```

### 4. shift()  删除首位元素

```js
// 4.shift  shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值  改变原数组。
  var arr = [1, 2, 3, 4, 5];
  var c = arr.shift();
  console.log(arr);//[2, 3, 4, 5]
  console.log(c);//1 
```

### 5.isArray() 判断是否是数组

```js
 // 5.isArray() isArray() 这个方法用来判断一个对象是不是数组，是的话返回true，否则返回false
  var arr = [1, 2, 3, 4, 5];
  console.log(Array.isArray(arr));//true
  var c = { 'name': 'hhh' };
  console.log(Array.isArray(c));//false
```

### 6. map()  依次处理元素

```js
//6.map() map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
  // map() 方法按照原始数组元素顺序依次处理元素。
  // 参数：item当前元素的值
  // index当前元素的索引值
  // arr当前元素属于的数组对象
  var arr = [11, 22, 33, 44, 55];
  let c = arr.map((item, index) => {
    console.log(item, index);//item  数组中的每一项   index 下标
    return item + 3
  });
  console.log(c);//[14, 25, 36, 47, 58]    数组中每一项都加三
```

### 7. filter()  过滤器

```js
// 7.filter() filter() 方法创建一个新的数组，过滤出数组中符合条件的所有元素，把这些元素放在新数组中返回
  // filter() 不会对空数组进行检测。
  // filter() 不会改变原始数组。
  // 参数：item当前元素的值
  // index当前元素的索引值
  // arr当前元素属于的数组对象
  var arr = [11, 22, 33, 44, 55];
  let c = arr.filter((item, index) => {
    return item > 30
  });
  console.log(c);//[33, 44, 55]
  console.log(arr);//[11, 22, 33, 44, 55]
```

### 8. every() 是否所有元素都满足

```js
//  8.every() every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。
  //   every() 方法使用指定函数检测数组中的所有元素：
  //   如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。
  //   如果所有元素都满足条件，则返回 true。
  //   every() 不会对空数组进行检测。
  //   every() 不会改变原始数组。
  //   参数：item当前元素的值
  //   index当前元素的索引值
  //   arr当前元素属于的数组对象
  var arr = [11, 22, 33, 44, 55];
  let c = arr.every((item, index) => {
    return item > 30
  });
  console.log(c);//false  数组内的所有元素都满足大于30的时候才会返回true
  console.log(arr);//[11, 22, 33, 44, 55]
```

### 9. some() 是否有元素满足条件

```js
  //9.some()  some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。
  // some() 方法会依次执行数组的每个元素：
  // 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
  // 如果没有满足条件的元素，则返回false。
  // some() 不会对空数组进行检测。
  // some() 不会改变原始数组。
  // 参数：item当前元素的值
  //      index当前元素的索引值
  //      arr当前元素属于的数组对象
  var arr = [11, 22, 33, 44, 55];
  let c = arr.some((item, index) => {
    return item > 30
  });
  console.log(c);//false  数组内的只要有一个元素满足大于30的时候就会返回true
  console.log(arr);//[11, 22, 33, 44, 55]
```

### 10. splice()  删除/插入

```js
  // 10.splice()  splice() 方法用于添加或删除数组中的元素。改变原始数组。
  // arr.splice(a) 从当前下标a开始  删除后面所有的元素  包含下标a
  // arr.splice(a,b) 从当前下标a开始  删除到下标b的元素  包含下标a和下标b
  //如果有三个以上的参数  前两个参数是删除开始和结束的下标  第三个参数及以后的参数  是要在删除位置依次插入的数据 
  // 如果仅删除一个元素，则返回一个元素的数组。 如果未删除任何元素，则返回空数组。
  var arr = [11, 22, 33, 44, 55];
  let c = arr.splice(1, 3, 8, 8);
  console.log(c);//[22, 33, 44]
  console.log(arr);//[11,8,8 55]
```

### 11. slice() 截取

```js
 // 11.slice()  slice() 方法可从已有的数组中返回选定的元素。  截取数组
  // slice()方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。
  // slice() 方法不会改变原始数组。
  // arr.slice(a) 从当前下标a开始  截取后面所有的元素  包含下标a
  // arr.slice(a,b) 从当前下标a开始  删除到下标b的元素  包含下标a 不包含下标b
  // 参数：start 规定从何处开始选取。如果该参数为负数，则表示从原数组的倒数第几个元素开始提取，slice(-2) 表示提取原数组中 的倒数第二个元素到最后一个元素（包含最后一个元素）。
  // end() 规定从何处结束选取。没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取
  var arr = [11, 22, 33, 44, 55];
  let c = arr.slice(1, 4);
  console.log(c);//[22, 33, 44]
  console.log(arr);
```

### 12. indexOf() 查询下标

```js
  //12.indexOf  indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
  // 如果没有找到匹配的字符串则返回 - 1。
  // indexOf() 方法区分大小写。
  var arr = [11, 22, 33, 33, 44, 55];
  let c = arr.indexOf(33);
  console.log(c);//2
```

### 13. includes() 是否包含某元素

```js
  // 13.includes() includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。
  var arr = [11, 22, 33, 3, 44, 55];
  let c = arr.includes(33);
  console.log(c);//true
```

### 14. concat() 数组合并

```js
// 14.concat()   concat() 方法用于连接两个或多个数组。
  // 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。
  var arr1 = [22, 33, 44];
  var arr2 = [55, 66, 77];
  let c = arr1.concat(arr2);
  console.log(c);// [22, 33, 44, 55, 66, 77]
```



### 15. join() 数组元素拼接成字符串

```js
  // 15.join() join() 方法用于把数组中的所有元素放入一个字符串。  //字符串转数组是str.split()
  // 该元素是通过指定的分隔符进行分隔的。
  var arr = [11, 22, 33, 33, 44, 55];
  let c = arr.join('**');
  console.log(c);//11**22**33**33**44**55
```

### 16. split()  字符串转数组

```js
  //16.split()  split() 方法用于把一个字符串分割成字符串数组。
  // split() 方法不改变原始字符串。
  let str = '123456';
  let arr = str.split('');
  console.log(arr);//['1', '2', '3', '4', '5', '6']
```

### 17. forEach() 

```js
  // 17.forEach()  forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。
  var arr = [11, 22, 33, 33, 44, 55];
  arr.forEach((item, index) => {
    console.log(item + index);
  });//11  23  35  36  48  60
```

### 18. sort()

```js
  // 18.sort()  sort() 方法用于对数组的元素进行排序。
  // 数组在原数组上进行排序，不生成副本。
  let arr = [8, 9, 3, 5, 4, 7]
  arr.sort();
  console.log(arr);//[3, 4, 5, 7, 8, 9]   此方法只能排10以内的
  // 
  let arr1 = [22, 5, 60, 12, 7];
  arr1.sort(function (a, b) {
    return a - b
  });
  console.log(arr1);//[5, 7, 12, 22, 60]  a-b正序   b-a倒序
```

### 19. reverse()

```js
 // 19.reverse() reverse() 方法用于颠倒数组中元素的顺序。
  let arr = [5, 7, 12, 22, 60];
  arr.reverse();
  console.log(arr);//[60, 22, 12, 7, 5]

  let arr1 = [1, 3, 5, 2, 4, 6];
  arr1.reverse();
  console.log(arr1);// [6, 4, 2, 5, 3, 1]
```

### 20. find()

```js
 // 20.find  find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。
  // find() 方法为数组中的每个元素都调用一次函数执行：
  // 当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。
  // 如果没有符合条件的元素返回 undefined
  // find() 对于空数组，函数是不会执行的。
  // find() 并没有改变数组的原始值。
  let arr = [1, 3, 5, 2, 4, 6];
  let c= arr.find(item => {
    return item > 3
  });
  console.log(c);//5   返回符合的第一个
```

### 21. findIndex()

```js
//  21.findIndex() findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。
  //   findIndex() 方法为数组中的每个元素都调用一次函数执行：
  // 当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。
  //   如果没有符合条件的元素返回 - 1
  //   findIndex() 对于空数组，函数是不会执行的。
  //   findIndex() 并没有改变数组的原始值。
  let arr = [1, 3, 5, 2, 4, 6];
  let c = arr.findIndex(item => {
    return item > 3
  });
  console.log(c);//2   返回符合的第一个元素的下标
```

### 22. fill()

```js
// 22.fill()  fill(value,start,end) 方法用于将一个固定值替换数组的元素。
  // 参数：value 必须，填充的值
  // start 可选，开始填充的位置
  // end 可选，停止填充的位置，默认为array.length
  let arr = [1, 3, 5, 2, 4, 6];
  arr.fill(6, 2, 4);
  console.log(arr);//[1, 3, 6, 6, 4, 6]  下标在2-4之间 不包含4的地方都有6来填充
```

### 23. keys()、values()、entries()

```js
  // 23. keys()是对键名的遍历、values()对键值的遍历、entries()是对键值对的遍历。
  var arr = [11, 22, 33, 44, 55];
  for (let item of arr.keys()) {
    console.log(item);//0 1 2 3 4 
  }
  for (let item of arr.values()) {
    console.log(item);//11  22  33  44  55 
  }
  for (let item of arr.entries()) {
    c
```

### 24.reduce

```js
 //24.reduce()  reduce()实现迭代数组的所有项(即累加器)，然后构建一个最终返回的值
  //reduce()方法从数组的第一项开始，逐个遍历到最后
  //4个参数：前一个值、当前值、项的索引和数组对象
  var arr1 = [1, 2, 3, 4, 5];
  var sum = arr1.reduce((prev, cur, index, array) => {
    return prev + cur;
  }, 10);   // 数组一开始加了一个初始值10，可以不设默认0
  console.log(sum);   // 25

```

### 25.lastIndexOf

```js
lastIndexOf方法返回传入一个测试条件（函数）符合条件的数组最后元素的位置。
```



### 1，什么是javaScript

JavaScript是一个基于对象和事件驱动的脚本语言

###### 对象：  要执行操作的主体

###### 事件：操作的行为，动作，叫做事件；

###### 脚本语言是一种编程语言，主要用于编写脚本程序。

1. JavaScript：主要用于网页开发，可以实现动态交互和效果。
2. Python：一种通用的高级脚本语言，易于学习和阅读，可用于多种目的，包括科学计算、网络编程、自动化任务等。
3. Ruby：一种简洁而优雅的脚本语言，注重开发人员的幸福感，广泛应用于Web开发。
4. Perl：一种强大的脚本语言，适用于文本处理、系统管理、网络编程等。
5. Shell 脚本：主要用于Unix和Linux系统上的系统管理和自动化任务。
6. PowerShell：Windows 上的强大脚本语言，提供了丰富的系统管理和自动化功能。

### 2，js的组成

javaScript 是由ECMAScript:   BOM： DOM: 组成的

###### ECMAScript:

ECMAScript标准制定了语法、变量和数据类型、运算符、逻辑控制语句、关键字、保留字、对象等一些列的语法标准

###### BOM：

Browser Object Model（浏览器对象模型）

提供了独立于内容与浏览器窗口进行交互的对象

只要是浏览器给我提供的功能，前进后退隐藏最小化最大关闭等等，统称为bom

###### DOM:

Document Object Model（文档对象模型）

页面上所有展示的内容，统称为dom

### 3，js的数据类型有哪些

| 数据类型  | 解释                                                         |
| --------- | ------------------------------------------------------------ |
| undefined | var age;<br/>变量age没有初始值，将被赋予undefined【基本数据类型】（未定义） |
| null      | 表示一个空值，与undefined值相等【对象】                      |
| number    | var score=90;      //整数<br/>var score=96.5;   //浮点数  带小数点 浮点类型 |
| boolean   | 布尔型：true和false                                          |
| string    | 被引号（单引号或双引号）括起来的文本<br/>var string1="老陈你真帅"; |
| object    | 属性的集合、每个属性都由‘名/值’对构成<br/>{<br/>name:'老陈'，<br/>age:18<br/>} |
| Array     | 数组                                                         |
| Function  | 函数                                                         |
| Date      | 日期                                                         |
| RegExp    | 正则表达式                                                   |
| Symbol    | 表示唯一的、不可变的值，用于定义对象属性中的唯一键。         |
| BigInt    | 表示任意精度的整数，用于处理超过 JavaScript 数字类型范围的大整数。 |

### 4，null和undefined的异同点【面试题】

`Undefined`和`Null`虽然是两种不同的基本数据类型，但是在某些情况也存在相同之处，下面看一下它们两者相同点和不同点。

**（1）相同点**

第一：`Undefined`和`Null`两种数据类型都只有一个字面值，分别是`undefined`和`null`.

第二：`Undefined`和`Null`类型在转换为`Boolean`类型的值时，都会转换为`false`.

第三：在需要将两者转换成对象的时候，都会抛出一个`TypeError`的异常。

第四：`Undefined`类型派生自`Null`类型，所以在非严格相等的比较下，两者是相等的。如下面代码所示：

**(2)不同点**

第一：`null`是`JavaScript`的关键字，而`undefined`是`JavaScript`的一个全局变量，也就是挂载在`window`对象上的一个变量，并不是关键字。

第二：在使用`typeof`运算符进行检测时，`Undefined`类型的值会返回`undefined`.而`Null`类型的值返回为`object`

第三：在需要进行字符串类型的转换时，`null`会转换成字符串`null`,而`undefined`会转换字符串`undefined`.

第四：在进行数值类型的转换时，`undefined`会转换为`NaN`,无法参与计算，而`null`会转换为`0`,可以参与计算。

第五：建议：无论在什么情况下都没有必要将一个变量显示的赋值为`undefined`。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为`null`.

## 选择结构

### 1，js变量命名规范（了解）

1、驼峰命名法

2、不能以关键字开头

3、起名的时候不能以数字开头

要遵循 字下美人数骆驼，其中字下美人可以开头，但是我们普遍不以下划线开头。

## fo循环

## 双重fo循环

## 内置对象 上

### 1.手写冒泡

```
var arr = [7,8,1,4,5,6,2,3,5];
for (var i=0 ;i<arr.length;i++){
        //8 //1
  for (var j =i+1;j<arr.length;j++){
    if (arr[i]>arr[j]){
      var c = arr[i];
      arr[i] = arr[j];
      arr[j] = c;
      // document.write(arr+'<br>');//可以看到每次的变化
    }
  }
}
document.write(arr);
```

### 2.数组排序的几种方法

```
1.双重for循环     //冒泡排序
2.sort           //10以内
3.arr.sort(function (a, b) {
  return b-a;
})              //(b-a)降序 (a-b)升序  
4.set
```

### 3.数组的方法有哪些

```js
1.join()                       通过一个分隔符，把数组内的所有元素拼接成一个字符串。(不改变原数组)
2.sort()                       数组排序(改变原数组)
3.push()                       数组末尾添加一个或多个元素(改变原数组)
4.unshift()                    数组首位添加一个或多个元素(改变原数组)
5.pop()                        删除数组最后一个元素(改变原数组)     
6.shift()                      删除数组的第一个元素(改变原数组)
7.concat()                     数组合并(不改变原数组)
8.splice()                     向数组中添加，或从数组删除，或替换数组中的元素(改变原数组)
9.reverse()                    数组反转(改变原数组)
10.slice(a,b)                  截取下标为a到下标为b生成一个新数组(不改变原数组)
11.find                        查找符合条件的第一个值(不改变原数组)
13.findIndex                   返回第一个满足条件元素的下标(不改变原数组)
14.filter                      过滤不符合条件的数据，把满足条件的元素筛选出来放到新数组中.(不改变						      原数组)
15.every                       判断数组中的元素是否都满足函数规则(不改变原数组)
16.some                        数组中每一项 只要有一个满足条件就返回true(不改变原数组)
17.map                         遍历数组并对数据进行二次的处理，有返回值(不改变原数组)
18.reduce                      求和(不改变原数组)
19.includes                    判断是否包含元素(不改变原数组)
20.forEarch                    遍历数组(不改变原数组)
21.indexOf                     查看第一次数据出现的位置未找到返回-1(不改变原数组)
22.lastIndexOf                 查看最后一次数据出现的位置未找到返回-1(不改变原数组)
23.keys(),values()             遍历取值
24.entries()                   获得值+键 返回对象
```

### 4.splice和slice的区别

```js
1.splice用于删除数组的元素，会改变原数组
    splice(a,b),a表示从哪个下标开始删除，b表示删除的个数
    splice(a,b,c),a表示从哪个下标开始删除，b表示删除的个数,c表示删除元素后替换的值

2.slice是查找数组内的元素，或者说是切割数组，不会改变原数组
	slice(a,b); a表示开始查找的下标，b表示查找结束的下标，但不包含b,会返回一个新数组
	splice(0) 相当于拷贝了一个新数组
    
3.splice只能用于数组，slice可以用于数组也可以用于字符串
```



## 内置对象 下

### 1，String对象方法.

| length              | 字符串的长度【属性】                                         |
| ------------------- | ------------------------------------------------------------ |
| charAt(a)           | 根据下标找字符，返回在指定位置的字符 ,字符串中第一个字符的下标是0,a代表下标,找不到是空 |
| concat(b)           | 连接字符串,b:被合并对象名,和+的作用一样，不修改字符串        |
| replace(/a/,'b')    | 用于在字符串中用一些字符替换另一些字符，把a字符替换为b字符；/a/表示只替换匹配到的第一个a，/a/g，表示替换全部的a |
| split(‘’)           | 把对象根据引号内的规则分割成字符串数组                       |
| indexOf(‘字符’)     | 根据字符找到所在的下标位置（只返回第一个下标）；如果找不到，返回-1； |
| lastIndexOf('字符‘) | 返回一个指定的字符串值最后出现的下标位置                     |
| toLowerCase()       | 将字符串转为小写                                             |
| toUpperCase()       | 将字符串转为大写                                             |

### 2，截取字符串三种方法

1、   对象名.substr(a,b); 第一个值开始的下标位置，第二个值截取的长度	

```js
  代码案例：
    var str = '你好世界我爱你';
    // console.log(str.substr(2)); //世界我爱你
    console.log(str.substr(2,4))  //世界我爱
```

2、   对象名.substring(a,b); 第一个值开始的下标位置，第二个结束的下标（不含b）

```js
var str = '你好世界我爱你';
//                        2开始的下标  
//                        4结束的下标 不包含结束的这一个位置
console.log(str.substring(2,4));//世界
```

3、  对象名.slice(a,b); 第一个值:开始的下标位置，第二个:结束的下标（不含b）

只写一个a的时候，从a开始，一直到截取最后（适用于上面是三个）

```js
var str = '你好世界我爱你';
//                        2开始的下标  
//                        4结束的下标 不包含结束的这一个位置
console.log(str.slice(2,4));//世界
```

### 3，Math对象

| 方法     | 描述                             | 示例                                                  |
| :------- | -------------------------------- | ----------------------------------------------------- |
| ceil()   | 向上取整                         | Math.ceil(25.5);返回26<br/>Math.ceil(-25.5);返回-25   |
| floor()  | 向下取整                         | Math.floor(25.5);返回25<br/>Math.floor(-25.5);返回-26 |
| round()  | 四舍五入                         | Math.round(25.5);返回26<br/>Math.round(-25.5);返回-25 |
| random() | 返回0.0~1.0(不包含1)之间的随机数 | 返回0.0~1.0(不包含1)之间的随机数                      |
| abs()    | 绝对值                           | Math.abs(-25.5)返回25.5<br/>Math.abs(25.5)返回25.5    |

### 4， 0.1+0.2==0.3？？ 为什么不等于0.3

答案是不等的

结果为：0.30000000000000004

为什么呢？

> 因为JavaScript的Number类型为双精度IEEE754  64位浮点类型。
>
> 第0位：符号位，0表示正数，1表示负数(s)
>
> 第1位到第11位：储存指数部分（e）
>
> 第12位到第63位：储存小数部分（即有效数字）f
>
> 即小数后面存储52位

十进制的0.1转换为二进制数据的时候，是无限循环的，但是js都number类型只能保存小数点后面52位，不能无限的存储

所以剩下的内容会采取类似四舍五入的方式丢弃，即0舍1入

所以就造成了精度的丢失

###### 如何解决精度丢失？

利用number.toFixed(2); 只保留小数点后面两位

别忘了，toFixed的结果是string，要进行隐私类型转换滴



## 函数 

### 1、js代码的检查装载阶段（预编译阶段）

此阶段进行变量和函数的声明和提升，但是不对变量进行赋值，变量的默认值为undefined。

> 大白话，就是讲所有的声明（此时可理解为变量声明），都提升到最当前作用域最上面的位置，有变量名，但是没有值，就叫只声明不赋值，所以默认值是undefined。

### 2、js代码的执行阶段

此阶段对变量进行赋值和函数的声明。

> 大白话：搞完步骤1以后，会对变量进行赋值。并从上向下执行。

```javascript
var a=1; //声明了一个全局变量
function func(){
  console.log(a); //输出：undefined。打印a，而在func这个作用域中已经声明了a变量，此时函数内部同名的a为局部变量，按照js的执行顺序，此时的a并未被赋值。
  var a=1;
  console.log(a); //输出：1。
}
```

 上面代码第一个a输出undefined。

原因：js作用域链的访问规则，当前作用域内存在要访问的变量a，所以使用当前作用域中的变量（就近原则）。再根据js代码的执行顺序，此时的a只是声明了而并未被赋值，默认为undefined，所以输出undefined。

### 3、函数的提升

###### 表达式函数会先把变量提升，

声明函数，会把整个的函数提升到当前作用域的最上面

```javascript
    fn();
    function fn(){
        console.log('aaa');
    }
    // fn();
    --------------------------------------------------------
    fn2();//报错  因为匿名函数，是用变量接收函数f  会先把变量提升到最上面
    var fn2 = function(){
        console.log('haha');
    }
    fn2();
```

### 4.变量提升时 函数 和 变量 谁在最前面

函数和全局变量在提升的时候 ，全局变量提升在了最前面

### 5.作用域链

一般情况下，变量取值是到创建这个变量的函数的作用域中取值。

但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域

这么一个查找过程形成的链条就叫做作用域链	**（就近原则 向上取值）**

### 6.什么是闭包，闭包有那些优缺点

```css
闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。
作用：延长变量作用域、在函数的外部可以访问函数内部的局部变量，容易造成内层泄露，因为闭包中的局部变量永远不会被回收

优点：      1:变量长期驻扎在内存中；
           2:避免全局变量的污染；
           3:私有成员的存在 ；
缺点:
    常驻内存 会增大内存的使用量 使用不当会造成内存泄露，详解：

（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。


//第二种回答方式
闭包的缺点：
滥用闭包函数会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量
因为垃圾回收机制，只会回收变量。清空没用被调用函数的作用域
只要形成闭包，作用域就不能被销毁，因为闭包存在的意义，就是保护闭包内的变量不被外部影响
如果将函数内部的变量return出来，只是return出来这一个值
而闭包，return的是，整个闭包函数的作用域，提供给外部使用，依旧保持函数内部结构

清除闭包：把闭包赋值为null
```



# 高级

## BOM

### 1.谈谈你对bom的理解，bom中有哪些对象？

| 对象                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| window                       | 窗口对象，可以用来控制当前窗口，或打开新的窗口。顶层对象，js中，最高的对象就是window |
| screen                       | 屏幕对象，获取屏幕相关信息                                   |
| navigator                    | 浏览器对象，通过这个对象可以判定用户所使用的浏览器           |
| history                      | 可以用来前进，或后退一个页面，管理浏览器的历史记录           |
| location                     | 地址对象，提供了URL的信息以及对URL操作的方法                 |
| LocalStorage、sessionStorage | 存储对象，可以用来存储数据和cookie向上，区别是它是为了更大容量存储设计的，在使用上也更加方便 |
| setTimeout、setInterval      | 用于设置定时器和间隔执行代码,而不是在函数在被调用立即执行    |
| document                     | 表示当前窗口或框架中加载的文档                               |

> bom是浏览器对象模型
>
> bom提供了独立与内容 与浏览器窗口交互的对象
>
> bom主要是 用于管理窗口和窗口之间的通信   所以核心对象是window

### 2.你知道间歇调用和超时调用么？他俩的区别是什么

```css
1)	超时调用使用window对象的setTimeout()方法  两个参数要执行的代码和以毫秒的时间  只执行一次  可以用clearTimeout()停止超时调用
2)	间歇调用和超时调用类似  它会接受的参数与setTimeout()相同 不加以干涉的情况下，间歇调用会一直执行 可以用clearInterval()停止间歇调用
```

## DOM

### 1.DOM常用API有哪些

>+ 创建节点
>
>>创建元素  createElement
>>
>>let div = document.createElement('div')
>
>> 创建文本节点 createTextNode
>>
>> let text = document.createTextNode('hello')
>
>> 克隆节点  cloneNode()
>>
>> cloneNode()接受boolean参数 默认false浅拷贝 只复制方法不复制子元素
>
>+ 页面修改
>
>> 添加子元素末尾添加节点  appendChild
>>
>> parent.appendChild(child)
>
>> 添加一个节点到另一个节点之前
>>
>> parent.insertBefore(新节点, 目标节点)
>>
>> 注意：（参照节点为必传参数，如果不传就会报错,参照节点为必传参数，如果不传就会报错）
>
>> 删除子节点  removeChild
>>
>> let childNode = parent.removeChild(childNode)
>>
>> 如果被删除的不是其子节点，会报错。
>
>> 替换节点 replaceChild 
>>
>> parent.replaceChild(新节点, 旧节点)
>
>+ 节点查询的5种方法
>
>> + document.getElementById()
>> + document.getElementsByTagName()
>> + document.getElementsByClassName()
>> + document.querySelector()
>> + document.querySelectorAll()
>
>+ 操作节点属性
>
>> + setAttribute()方法添加指定的属性，并为其赋指定的值
>>   document.getElementById("changePic").setAttribute("src","image/change.jpg");
>> + getAttribute() 方法返回指定属性名的属性值
>>   alert(document.getElementById('changePic').getAttribute('src'));
>> + removeAttribute() 方法删除指定的属性
>>   document.getElementById("changePic").removeAttribute("src","image/change.jpg");



### 2.**childNodes 和 children 的区别：**

```css
children与childNodes都是获取目标元素的子节点,childNodes包含children，不同的是：

<1>	children是非标准的，仅返回HTML节点。甚至不返回文本节点
childnodes：它是标准的，返回包括HTML节点，所有属性，文本。可以通过nodeType来判断是哪种类型的节点， 当nodeType==1是元素节点，2是属性节点，3是文本节点。

<2>	childNodes属于NodeList集合，它会返回所有的子节点，包括文本、标签、注释等等。
children数据HTMLCollection集合，它会返回所有HTML元素节点。

```



## 事件 上

### 什么是事件

```
事件是文档或者浏览器窗口中发生的，特定的交互瞬间
```

### 绑定事件的三种方法

```js
var btn=document.getElementById("btn");
//DOM 事件绑定
btn.onclick=function(){
	alert("我是第一种绑定事件的方法");
}

//事件监听
//el_obj.addEventListener(1,2,3);
//    1: 要监听的事件名（不加on）
//    2: 事件的处理函数，即时间要执行的函数
//    3： boolean:true false(默认)
//        --false：事件冒泡  默认
//        -- true: 事件捕获
btn.addEventListener("click",function(){
	alert("我是第二种绑定事件的方法");
},false)
//    给dom元素删除事件监听    
//    el_obj.removerEventListener(1,2);
//    1: 要删除的事件名
//    2：相关的事件处理函数（注意：该函数需要时一个外部处理函数）
//    btn_2.removeEventListener('click', fn);

//内联事件绑定
function clickFn(){
	alert("我是第三种绑定事件的方法");
}
<button onclick="fn_3()">点击</button>
```

### 事件绑定和普通事件的区别

```css
普通添加事件和事件绑定方式添加事件的区别：

		普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，

		而事件绑定（addEventListener）方式添加事件可以添加多个。
```

### 什么是事件流  分别有那些  是什么

```css
所谓事件流，就是从页面中接收事件的顺序

分别有冒泡型 和 捕获型  

事件冒泡：(从内到外)
         定义：就是事件从开始目标，往上一直冒泡到页面最顶层对象（window）。
         形象比喻：就像水里是小鱼吐气时，气泡会从吐气时的位置一直往上冒泡到水面，最后破裂。
         有哪些：所有事件默认都是冒泡模式  事件绑定的第三个参数 不写 或者为 false 的时候也是冒泡
事件捕获：(从外到内)
        定义：事件从被点击元素是层级最高的祖先元素（设置捕获-true）开始，一直渗透到其下所有的子元素
        形象比喻：老板一声令下，各级员工依次干活 。
        有哪些：事件绑定 只有的第三个参数为true的时候才为捕获型
```

### 鼠标事件

| 事件名       | 描述                             |
| :----------- | :------------------------------- |
| onclick      | 鼠标点 击某个对象 单击           |
| ondblclick   | 鼠标双击某个对象                 |
| onmouseover  | 鼠标被移到某元素之上【伤及子孙】 |
| onmouseout   | 鼠标从某元素移开【伤及子孙】     |
| onmousedown  | 某个鼠标按键被按下               |
| onmouseup    | 某个鼠标按键被松开               |
| onmousemove  | 鼠标被移动                       |
| onmouseenter | 鼠标从元素移入【不伤及子孙】     |
| onmouseleave | 鼠标从元素移出【不伤及子孙】     |

```css
onmouseover、nmouseout：    鼠标移动到自身时候会触发事件，同时移动到其子元素身上也会触发事件
onmouseenter、onmouseleave：鼠标移动到自身是会触发事件，但是移动到其子元素身上不会触发事件
```

### 表单事件

| 事件名   | 描述                           |
| -------- | ------------------------------ |
| onfocus  | 元素获得焦点                   |
| onblur   | 元素失去焦点                   |
| onchange | 用户改变域的内容               |
| onreset  | 表单重置时触发【绑定在form上】 |
| onsubmit | 表单提交时触发【绑定在form上】 |
| oninput  | 用户输入时                     |

### 键盘事件

| 事件名     | 描述                                 |
| ---------- | ------------------------------------ |
| onkeydown  | 某个键盘的键被按下                   |
| onkeypress | 某个键盘的键被按下并释放一个键时发生 |
| onkeyup    | 某个键盘的键被松开                   |

> 键盘事件的事件次序：onkeydown		onkeypress		 onkeyup

### UI事件

UI（User Interface，用户界面）事件        指的是那些不一定与用户操作有关的事件

| **事件名** | **描述**                 |
| ---------- | ------------------------ |
| onload     | 某个页面或图像被完成加载 |
| onresize   | 窗口或框架被调整尺寸     |
| onscroll   | 当文档被滚动时发生的事件 |



## 事件 下

### event对象是什么  用来干什么  怎么写

```js
//就是一个js对象，里面包含了事件的详细具体信息

//用来获取事件的详细信息：鼠标位置、键盘按键

//获取event对象（兼容性写法）
//语法： ver e = e||window.event;
document.onclick=function(e){
        ver e = e||window.event;
	   alert(e.clientX+','+e.clientY);
}
```

### event对象属性

| 属性          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| altKey        | 返回当事件被触发时，"ALT”是否被按下。                        |
| button        | 返回当事件被触发时，哪个鼠标按钮被点击。0 左键 1中间键 2右键 |
| clientX       | 返回当事件被触发时鼠标指针向对于浏览器页面(或客户区〉的水平坐标客户区指的览器的有效区域【dom左】 |
| clientY       | 返回当事件被触发时鼠标指针向对于浏览器页面(或客户区）的垂直坐标客户区指的览器的有效区域 【dom上】 |
| ctrlKey       | 返回当事件被触发时，"CTRL”键是否被按下。                     |
| metakey       | 返回当事件被触发时，"meta”键是否被按下。window键   command键盘 |
| relatedTarget | 返回与事件的目标节点相关的节点。                             |
| screenX       | 返回当某个事件被触发时，鼠标指针的水平坐标。鼠标相对于显示器屏幕x轴的位置 |
| screenY       | 返回当某个事件被触发时，鼠标指针的垂直坐标。鼠标相对于显示器屏幕Y轴的位置 |
| shiftKey      | 返回当事件被触发时，"SHIFT”键是否被按下。                    |
| pageX         | 返回的值：当前点击的点，距离整个页面最左边的距离             |
| pageY         | 返回的值：当前点击的点，距离整个页面最上面的距离【e.clientY+ scrollTop】 |
| offsetX       | 点击事件中，点击的位置，距离出发点击事件的节点（元素）左边的距离 |
| offsetY       | 点击事件中，点击的位置，距离出发点击事件的节点（元素）上边的距离 |

###  鼠标位置

1、screenX 和screenY

参照点：电脑屏幕左上角
screenX：鼠标点击位置相对于电脑屏幕左上角的水平偏移量
screenY：鼠标点击位置相对于电脑屏幕左上角的垂直偏移量

2、clientX和clientY

参照点：浏览器内容区域左上角 dom区域
clientX：鼠标点击位置相对于浏览器可视区域的水平偏移量（不会计算水平滚动的距离）
clientY：鼠标点击位置相对于浏览器可视区域的垂直偏移量（不会计算垂直滚动条的距离）
3、pageX和pageY

参照点：网页的左上角
pageX：鼠标点击位置相对于网页左上角的水平偏移量，也就是clientX加上水平滚动条的距离
pageY：鼠标点击位置相对于网页左上角的垂直平偏移量，也就是clientY加上垂直滚动条的距离
4、offsetX和offsetY

offsetX：鼠标点击位置相对于触发事件对象的水平距离
offsetY：鼠标点击位置相对于触发事件对象的垂直距离

### 阻止事件冒泡

```js
window.event ? window.event.cancelBubble = true : event.stopPropagation();
```

### 阻止默认行为

```js
1.  e.preventDefault();    //兼容非ie
2.  e.returnValue = false; //兼容ie
写法： window.event? e.returnValue = false :e.preventDefault();
3.  return false;          //必须放在函数代码的末尾
```

### 什么是防抖：  什么是节流：  他俩的区别

```css
防抖：
    连着点了好多次，我们想要点击停止后间隔一定的时间 执行一次
    一些频繁触发的事件，我们不想让它频繁执行，点击停止后间隔一定的时间 执行一次
节流：
    不论执行的频率有多高 ，我们总是让间隔一定的时间执行一次
    一些频繁触发的事件，我们想让它频繁执行，但不想那么的频繁，间隔一定的时间执行一次
区别：
    防抖：不论执行多少次，我们只让最后一次执行
    节流：一段时间内，可以执行多次效果，但是我们人为的降低了执行的频率
```

### 讲一下防抖和节流，防抖和节流的应用场景

```css
防抖:如果事件被频繁触发,防抖保证只能有一次触发生效,前面N多次触发都会被忽略
	（手写防抖）
		var timer=null;
		btn.onclick=()=>{
			clearTimeOut(timer)
			timer=setTimeOut(()=>{
				conslole.log('防抖了')
			},1000)
		}
		
节流:如果短时间被频繁触发,节流能减少事件触发的频率,因此,节流是有选择性的执行一部分事件
	(手写节流)
		var flg=true;
		btn.onclick=()=>{
			if(flg){
				flg=false
					consloe.log('节流了')
					setTimeOut(()=>{
						flg=true
					},1000)
			}
		}
		
		
引用lodash库进行防抖节流
防抖：btn.onclick=_.debounce(function(){
                    console.log('防抖执行了')
                     }，1000)
节流：btn.onclick=_.throttle(function(){
                    console.log('节流执行了')
                     }，1000)                    	
```



## 正则表达式

### 1、常用的元字符(特殊字符)

| 字符 | 描述                       |
| ---- | -------------------------- |
| \w   | 匹配数字、字母、下划线     |
| \W   | 匹配非数字、字母、下划线   |
| \d   | 匹配数字                   |
| \D   | 匹配非数字                 |
| \s   | 匹配空白字符（空格、换行） |
| \S   | 匹配非空白字符             |
| \n   | 匹配换行符                 |

### 2、常用的限定字符

| 字符  | 描述                         |
| ----- | ---------------------------- |
| *     | 匹配前面的子表达式零次或多次 |
| +     | 匹配前面的子表达式一次或多次 |
| ？    | 匹配前面的子表达式零次或多次 |
| {n}   | 匹配确定的n次                |
| {n,}  | 至少匹配n次                  |
| {n,m} | 最少匹配n次最多匹配m次       |
| ^     | 以某某某开头                 |
| $     | 以某某某结尾                 |
| \     | 转义字符                     |

### 3、修饰符

| 修饰符 | 描述                                                 |
| ------ | ---------------------------------------------------- |
| i      | 执行对大小写不敏感的匹配                             |
| g      | 执行全局匹配(查找所有匹配而非在找到第一个匹配后停止) |
| m      | 执行多行匹配                                         |

### 4、常用表达式

| 表达式 | 描述                                                         |
| :----: | ------------------------------------------------------------ |
| [a-z]  | 查找任何从小a到z的字符  -  表述区间                          |
| [A-Z]  | 查找任何从大写A到大写Z的字符                                 |
| [0-9]  | 查找任何从0至9的数字                                         |
| [abc]  | [abc]查找括号内的任意一个字符                                |
| [^abc] | 查找除了括号内的任意字符,除了abc如果还有其他任意字符为true否则false |

### 5、正则表达式方法

检查一个字符串是否与正则相匹配

reg.test(string)		返回值为布尔值	true匹配	false不匹配

reg.exec(string)	   匹配成功返回数组,并确定其位置,否则返回null

### 6、 String对象中可以支持正则表达式的方法

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| exec     | 匹配成功返回数组,并确定其位置,否则返回null                   |
| test     | 验证正则表达式,返回值为布尔值	true匹配	false不匹配     |
| search   | 检索与正则表达式相匹配的值,查找不到返回-1,查找到返回第一个匹配的下标 |
| match    | 检索一个或多个正则表达式的匹配,如果没有找到任何匹配的文本,返回null,否则他将返回一个数组(依赖于是否具有全局表示g) |
| matchAll | 在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。 |
| replace  | 替换与正则表达式匹配的字符串,返回一个新的字符串              |
| split    | 把字符串分割为字符串,返回一个字符串数组                      |

## 同步异步

### 1.如何理解JS单线程？

```css
  JavaScript是一种单线程语言，这意味着它只能同时执行一个任务。这是因为JavaScript的设计初衷是用于在浏览器中操作DOM（文档对象模型），而DOM是单线程的。因此，JavaScript引擎只能按照顺序执行代码，一次只处理一个任务。

  单线程的设计使得JavaScript具有一些特点和限制。首先，它可以避免多线程编程中的一些复杂性和竞态条件。其次，它可以确保代码的执行顺序是可预测的，避免了并发执行带来的问题。

  然而，单线程也有一些缺点。当执行一个耗时的任务时，JavaScript的执行会被阻塞，导致页面无响应。为了解决这个问题，可以使用异步编程技术，如回调函数、Promise和async/await，来处理耗时任务，使得JavaScript在执行这些任务时可以继续响应其他事件。
```

### 2.谈一谈同步和异步？

```css
同步和异步是指代码执行的方式和顺序的不同。
同步是指代码按照顺序执行，每个任务必须等待前一个任务完成后才能执行。在同步操作中，代码会阻塞后续的执行，直到当前任务完成。
异步是指代码可以同时执行多个任务，不需要等待前一个任务完成。
```

### 3.任务队列(Event Queue)和Event Loop(事件循环)？

```css
  任务队列：所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

  Event Loop(事件循环)：只要主线程空(代表同步任务执行完了，就会读取“任务队列”)，这就是JavaScript的运行机制。这个过程会不断重复。
```

### 4.异步任务有哪些？

```
定时函数setTimeout和setInterval; DOM事件绑定; Ajax操作; NodeJS中的fs文件读写等。
```

### 5.js单线程又是如何实现异步的呢?

```css
通过事件循环(event loop)实现'异步'。
```

### 6.js为什么需要异步?

```css
如果JS中不存在异步,只能自上而下执行（js是单线程的语言）,万一上一行解析时间很长,那么下面的代码就 会被阻塞。
对于用户而言,阻塞就意味着"卡死",这样就导致了很差的用户体验。 
```

### 7.JS执行机制总结

```css
  js是一个单线程语言，把所有的任务分为了同步任务和异步任务。
  在执行的时候，首先判断js代码是同步还是异步，同步就进入主线程，异步就进入任务队列(event queue)。
  同步任务进入主线程后一直执行（从上往下），直到主线程空闲时（表示同步任务执行完毕）,此时才会去任务队列(event queue)中查看是否有可执行的异步任务，如果有就将任务队列中的异步任务推入主线程中进行执行。
  异步任务执行的时候，若时间一样，从任务队列那里从上往下执行，如果时间不一样，时间短的先执行。
```

## Ajax

### 1.Ajax工作原理

```
Ajax（Asynchronous JavaScript and XML）是一种用于创建交互式网页应用程序的技术。它通过在后台与服务器进行异步通信，实现在不刷新整个页面的情况下更新部分页面内容。Ajax使用JavaScript和XML（现在通常使用JSON）来实现数据的异步传输。它的工作原理是通过使用XMLHttpRequest对象向服务器发送请求，并在接收到响应后更新页面的特定部分。这使得网页能够实时地获取和显示数据，提高了用户体验。
```

### 2.创建Ajax的步骤

```js
1.创建Ajax对象
     非IE6语法：
       var oAjax=new XMLHttpRequest();

     老版本IE5 和 IE6语法：
       var oAjax=new ActiveXObject("Microsoft.XMLHTTP")

     写法：
       var oAjax = new XMLHttpRequest() ||new ActiveXObject('Microsoft.XMLHTTP');
         
2.连接到服务器
      语法：
         open(方式，后台地址（文件名），同步异步)
         参数一：post/get  (网络请求的方式)
         参数二：请求的文件名（后台地址）
         参数三：同步（false）  异步（true）   【默认异步】
                    同步交互：指发送一个请求，需要等待返回，然后才能够发送下一个请求，有个等待过程
                    异步交互：指发送一个请求，不需要等待返回，进入了任务队列，等待同s步执行完，再来执行异步的请求
                    
       建立连接写法
            ajax_.open('get','url',true);
            
3.发送请求
      语法：
          ajax_.send();

      如果是get请求，请求数据放在open的url中。
          ajax_.open('get','url'+?数据，true);
      如果是post请求，请求数据放在send（）中； 
          ajax_.send(数据)
       
       
4.接收返回值

接收服务器返回结果，得到返回值。此时会触发onreadystatechange 事件
如果后台响应的是xml文件， ajax_.responseXML;
其余的用： ajax_.responseText;进行解析响应数据

  请求状态码 readyState：
从 0 到 4 发生变化
0: 请求未初始化（还没有调用到open方法）
1: 服务器连接已建立（已调用send方法，正在发生请求）
2: 请求已接收（send方法完成，已接收到全部请求内容）
3: 请求处理中（解析响应内容）
4: 请求已完成，且响应已就绪

  响应状态码 status：
200："OK"
404：未找到页面
500： 服务器内部错误
```

### 3.Ajax封装


```js
<script>
        // 1、创建对象
       var ajax_ = new XMLHttpRequest() || new ActiveXObject('Microsoft.XMLHTT');
        //2、建立连接
        ajax_.open('get','http://jsonplaceholder.typicode.com/posts',true);
        //3、发送请求
        ajax_.send();
        //4、接收服务器数据
        ajax_.onreadystatechange = function(){
           /*  if(ajax_.readyState==4 &&ajax_.status == 200 ){
                console.log(ajax_.responseText);
            } */
            if(ajax_.readyState==4){
                if(ajax_.status==200){
                    console.log(ajax_.responseText);
                }else{
                    console.log('获取连接失败');
                }
            }
        }
</script>
```

### 4.get和post请求的区别：

|                      | **GET**                                                      | **POST**                                                     |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **缓存**             | **能被缓存**                                                 | **不能缓存**                                                 |
| **历史**             | **参数保留在浏览器历史中**                                   | **参数不会保存在浏览器历史中**                               |
| **对数据长度的限制** | **当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度IE是 2048 个字符,chrome 最大长度8182个字符）** | **无限制**                                                   |
| **对数据类型的限制** | **只允许 ASCII 字符**                                        | **没有限制，也允许二进制数据**                               |
| **安全性**           | **与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分** | **POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中** |
| **可见性**           | **数据参数在 URL 中对所有人都是可见的**                      | **数据不会显示在 URL 中**                                    |

### 5.http状态码都有那些？

```css
200 : 成功，表示访问成功，正常状态。

301 : 永久移动，表示本网页已经永久性的移动到一个新的地址，在客户端自动将请求地址改为服务器返回的新地址。

302 : 临时重定向，表示网页暂时性的转移到一的新的地址，客户端在以后可以继续向本地址发起请求。

303 : 表示必须临时重定向，并且必须使用GET方式请求。

304 : 重定向至浏览器本身，当浏览器多次发起同一请求，且内容未更改时，使用浏览器缓存，这样可以减少网络开销。

401 : 表示协议格式出错，可能是此IP地址被禁止访问该资源，与403类似。

403 : 表示没有权限，服务器拒绝访问请求。

404 : 这是最常见的错误，表示找不到系统资源，但是只是暂时性地。

500 : 表示服务器程序错误，一个通用的错误信息。

503 : 表示服务器繁忙，或者服务器负载，通常这只是一个临时状态。
```

### 6.json概念

```css
JSON是一种轻量级的数据交换格式，它基于 ECMAScript 的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据

文件类型： 后缀名为json
```

### 7.JSON 语法规则

```css
--数据在 名称/值对中  键值对

{"name" : "二狗"}

--数据由逗号分隔

{"name" : "苍空空","age":"38","address":"日本"}

--大括号保存对象

--中括号保存数组


```

### 8.json字符串转json对象

```css
 在前后台数据交互时，数据是以json字符串的形式来传递的。为了方便我们操作数据，需要把json字符串转成json对象来使用
 
 --方法1：eval（）函数

   语法：eval('('+json+')')
 
   写法：
    var json_ = ajax_.responseText;
    json_ = eval('('+json_+')');
 
--方法2：json.parse(数据)

   写法：
     var json_ = ajax_.responseText;
     json_ = JSON.parse(json_);
```



## 跨域

### 1.什么是跨域

```css
跨域，指的是浏览器不能执行其他网站的脚本。当浏览器执行一个跨源（跨域）请求时，如果请求的目标不与当前页面的源（协议、域名、端口）相同，就会发生跨域请求。

例如，当你的网页尝试通过 Ajax 请求访问不同域名下的 API 接口时，就会触发跨域请求。

简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。

例子：比如淘宝网不能请求京东的数据

```

### 2.跨域产生的原因

```css
跨域产生的原因是浏览器的同源策略（Same-Origin Policy）限制而产生的。同源策略是一种安全机制，它会阻止网页的 JavaScript 代码获取或操作来自不同源的资源，以保护用户的安全和隐私。

为了克服这个限制，需要采取跨域解决方法，例如：JSONP、CORS 或代理服务器等。

同源策略大白话：

生活中，社会能够安定的运行，有一个前提，大家都默认遵守一个协定：每个人只能自由的出入自己的家，拿取自己家的东西。而如果大家都不遵循这种协定，你可以随便去拿别人家的东西，别人也可以随便的出入你的家，这样社会就乱套了。此处大家都遵循的各用各家的东西，就叫做同源策略

```

### 3.同源的理解

```css
源指的是协议（如http或https）、域名和端口的组合。

域名和ip地址：

比方说，我们要去逛永辉超市，在导航里面输入永辉超市，导航会找到永辉超市的地址，在某某街某某号，并导航到这个位置。

这里我们输入永辉超市就好比输入一个域名，但是系统会将它转换为具体的街道门牌号，这个就好比网络上的ip地址，是精确且唯一的。

http 通讯协议 如果没有写端口号 默认是80
```



### 4. 跨域的限制

```css
1.无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。【缓存数据】

2.无法接触非同源网页的 DOM。

3.无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）
```

### 5. 跨域解决方案

#### 1. 设置CORS跨域资源共享 后台解决的

```css
  response.setHeader("Access-Control-Allow-Origin", "*");
  
  “*”表示所有的域都可以接受
  
   CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。
   
   CORS 的优点是支持各种类型的请求，并且可以处理复杂的请求和响应。
```

#### 2. JSONP 

JSONP是一种利用 <script> 标签可以跨域加载资源的特性来解决跨域请求的方法

```css
它通过动态创建 <script> 标签，并在请求的 URL 中指定一个回调函数名。服务器在返回数据时，将数据作为参数传递给回调函数，从而实现跨域数据的获取。

Jsonp 实现思路:

1. 全称是 JSON with Padding，请求时通过动态创建一个 Script，在 Script 中发出请求。
2. 通过这种变通的方式让请求资源可以跨域。
3. 它不是一个官方协议，是一个约定，约定请求的参数里面如果包含指定的参数（默认是 callback），就说明是一个 JSONP 请求，服务器发现是 JSONP 请求，就会把原来的返回对象变成 JS 代码。
4. JS 代码是函数调用的形式，它的函数名是 callback 的值，它的函数的参数就是原来需要返回的结果。
5. 后台会把函数调用，重新返回给前端。

JSONP优缺点:

优点：兼容性强,不受同源策略的限制
缺点：只能用get方法，不能使用post方法

因为get请求方式把请求参数放在了url地址中，后台解析jsonp是通过url的callback参数进行判断的，所以之支持get请求
```

json.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>模拟jsonp</title>
</head>
<body>
  // 传参并指定回调执行函数为onBack
 <script src="./testjs.js?callback=onBack"></script>
<script>
 <!-- 
       通过script的src属性进行跨域
       传递的参数默认是callback
       后台看到callback就能够判断出来是一个jsonp请求
       会根据callback的值，自动生成函数，函数名就是callback的值
       后台把数据，作为参数传递给函数作为值
    -->
// 回调执行函数（ 调用后台函数）
function onBack(value) {
    console.log(value);
}
</script>
</body>
</html>
```

testjs.js

```js
// testjs.js就是我们模拟的后台
// 后台能判断出来是否是jsonp请求
// 如果是，就会生成一个函数的调用，而函数名，就是前端提交上来的callback的值在假如我们要给前端返回一个数据

var data = {
    "name":"张三",
    age : 20,
    address:"郑州"
}

// 在后台生成了函数的调用，把数据以参数的形式，进行传递
// 后台会把这个函数的调用，重新返回给前端
onBack(data);

```

#### 3. Ajax 跨域请求 (代理服务器)

```css
由于在工作中需要使用AJAX请求其他域名下的资源，但是会出现拒绝访问的情况，这是因为基于安全的考
虑，AJAX只能访问本地,同域的资源，而不能跨域访问可以让服务器去别的网站获取内容然后返回面.

代理服务器是一种将跨域请求转发到目标服务器的中间服务器。

客户端发送请求到代理服务器，代理服务器再将请求转发到目标服务器，并将目标服务器的响应返回给客户端。由于代理服务器与目标服务器在同源下，因此不存在跨域问题。

代理服务器的优点是可以处理各种类型的请求，并且不需要对目标服务器进行任何修改。但它需要额外的服务器来充当代理，增加了系统的复杂性和维护成本。

大白话：
我们要租房子，房源被中介给垄断了，我们无法直接找到房东。
我们先找到中介，中介去和房东谈具体事宜，谈好以后把每个月多少钱的信息告诉我们。
```

#### 4. WebSocket (了解)

WebSocket 是一种通信协议，和http,https是同一级别的。

使用ws://（非加密）和wss://（加密）作为协议前缀。

该协议不实行同源政策，只要服务器和浏览器支持，就可以通过它进行跨源通信。
缺点
只有在支持websocket协议的服务器和浏览器上才能正常工作

websocket不支持ie6以下的浏览器

## cookie&stroage

### 1，Cookie实现原理

```css
实现原理：基于请求头cookie和响应头 setCookie 实现

当客户端发送请求以后，服务器把Cookie数据以响应头的方式返回客户端类型：set-cookie:名=值

当客户端看到set-cookie的响应头，自动把数据保存到客户端

客户端下次请求的时候，自动携带保存的数据请求，并把数据放入cookie:名=值，的请求头里面【可通过抓包工具进行查看
```

### 2，Cookie特性

```css
1、同一个网站中所有页面共享一套Cookie,cookie是按照域名进行存储的。
2、数量、大小有限4-10k。
3、过期时间，因为存储的空间太小了，所以到期就把数据给清理掉了。
4、每次会随着HTTP请求发送给服务器
```

### 3，Cookie的缺点

```css
1、隐私问题：Cookie可以追踪用户的行为和偏好，可能泄露个人信息，引发隐私顾虑。

2、安全风险：恶意攻击者可以利用Cookie进行跨站脚本攻击（XSS）或跨站请求伪造（CSRF）等攻击，窃取用户信息。

3、存储限制：每个域名下的浏览器通常只允许存储有限数量和大小的Cookie。这可能限制了网站在跟踪、存储和管理用户相    关信息方面的灵活性。

4、跨设备限制：Cookie是与浏览器绑定的，不同设备上的不同浏览器无法共享Cookie，这可能导致用户体验的不一致。

5、第三方Cookie问题：第三方Cookie由不同于当前浏览网站的域名设置，可能用于广告追踪和数据收集，引发隐私担忧。

6、清理和控制困难：用户可能需要手动清理Cookie，而且控制Cookie的具体行为和选择删除哪些Cookie可能需要具体设    置。
```

### 4，Cookie的优点

```css
1、个性化体验：Cookie可以存储用户的偏好设置和个人化信息，使网站能够提供更符合用户需求的个性化体验。

2、用户认证：Cookie可以用于用户认证，使用户在访问网站时无需重复登录，提高用户的便利性和体验。

3、购物车和会话管理：Cookie可以用于存储购物车信息和会话状态，使用户在购物过程中能够方便地添加、删除和修改商    品，保持购物车的持久性。

4、网站统计和分析：Cookie可以用于跟踪用户的访问行为和流量来源，帮助网站分析用户行为和改进网站性能。

5、广告定向和营销：Cookie可以用于广告定向，根据用户的兴趣和行为向其展示相关的广告，提高广告的效果和点击率。

6、跨页面状态保持：Cookie可以用于在不同页面之间传递状态信息，使网站能够保持用户的特定状态，如语言选择、主题设    置等。
```

### 5，Storage本地存储

```css
1、容量最小5MB，但是可以申请更大的空间。

2、不会随着HTTP请求发送给服务器

3、非常容易操作

4、移动端普及高

5、他有两种分别是localStorage与sesssionStorage

6、localStorage只要不删除 永久存储

7、sesssionStorage页面关闭 立即消失
```

### 6，和storage对比cookie的缺点

```css
1、只能存储4KB

2、浪费宽带，每次会随着HTTP请求发送给服务器

3、操作数据很繁琐，没有方便的API

4、存储默认20分钟，页面关闭就消失， 可以人为的设置过期时间
```

### 7，localStorage-本地存储

```css
1、 为永久性保存数据，不会随着浏览器的关闭而消失，可以在同域名跨页访问。

2、 按域名进行存储，不会和其他域名冲突

3、 键值对存储：key/value

4、localStroage存储数据，value必须是字符串，localSorage存储的值，如果存储的是对象，则无法正常显示

5、 所以如果想要存储的值是对象，需要先把对象转为字符串

JSON.parse(字符串);  字符串  转为  对象

JSON.stringify(对象);   对象 转为 字符串

6、localStorage.setItem(key , value)，保存或设置数据

7、如果key已经存在，则覆盖key对应的value

8、如果不存在则添加key与value
```

### 8，sessionStorage

```css
sessionStorage为临时性保存数据，当页面关闭就会消失。其他一切与localStorage一样

sessionStorage不能跨页面访问，也不会触发跨标签页的storage事件。它只局限在当前的标签页

存储临时性数据

其他的方法属性和localStorage一样
```

### 9，cookie和localStorage 和sessionStorage的区别

|      特性      | cookie                                                       | localStorage                                                | sessionStorage                                              |
| :------------: | ------------------------------------------------------------ | :---------------------------------------------------------- | ----------------------------------------------------------- |
| 数据的生命周期 | 一般由服务器生成，可以设置失效时间，如果在浏览器段生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存                                    | 近在当前会话下有效，关闭页面或浏览器后被删除                |
|  存放数据大小  | 4K左右                                                       | 一般为5MB                                                   | 一般为5MB                                                   |
| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 尽在客户端（即浏览器）中保存，不参与和服务器的通信          | 尽在客户端（即浏览器）中保存，不参与和服务器的通信          |
|     易用性     | 需要程序员自己来封装，原生的Cookie接口不友好                 | 原生接口可以接受，亦可再次封装来对object和Array有更好的支持 | 原生接口可以接受，亦可再次封装来对object和Array有更好的支持 |



## 封装



### 1，创建对象有哪些模式

```css
1.工厂模式
2.构造函数模式
```

### 2，谈一谈工厂模式与其弊端

```css
工厂模式

软件工程领域的一种设计模式
抽象了创建对象的过程
把创建对象的过程封装在了函数中
工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

弊端

1.看不出内在联系
2.不变的内容重复调用

```

### 3，谈一谈构造函数

```css
为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（Constructor）模式。构造函数一般以大写字母开头

构造函数也是函数，只不过可以用来创建对象,内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。

构造函数的this指向:构造函数的this指向当前构造函数的实例对象（new构造函数得到的对象）
```

### 4，构造函数模式与工厂模式的区别

```css
1、没有显式创建对象，创建对象使用的new 构造函数的方法

2、直接将属性和方法赋给了this对象

3、没有return
```

### 5，构造函数和普通函数的区别

```css
1、书写方式的不同：普通函数 首字母小写  构造函数 首字母大写

2、this指向不同：普通函数 this指向window  构造函数 this 指向当前构造函数的实例  (new 构造函数得到的新对象

3、调用的方式的不同：普通函数调用使用 函数名（）， 构造函数 new 构造函数名（）  得到一个新的对象
```

### 6，prototype原型对象

```css
- 每个构造函数都有一个prototype（原型）属性

- prototype是一个指针，指向一个对象

- prototype原型对象的所有属性和方法，都会被其指向的构造函数的实例继承（共享）。
```

### 7，instanceof 、typeof和constructor的区别

```css
instanceof：可以验证原型对象与实例对象之间的关系

typeof：运算符返回一个字符串，用来检测变量的数据类型。

constructor：实例对象的一种方法可以用来指向它们的构造函数

1、typeof判断所有变量的类型，返回值有number、string、boolean、function、object、undefined。

2、typeof对于丰富的对象实例，如数组，日期只能返回object，导致有时候得不到真实的数据类型。

3、instanceof用来判断对象，代码形式（obj1 instanceof obj2）（判断obj1是否为obj2的实例），obj2必须为构造函数或者对象，否则会报错。返回的是布尔值。  用来精准的判断，对象是否是由某构造函数创造出来的，结果是true 或者false （亲子鉴定）

4、constructor 用来查找当前实例对象的构造函数（找爸爸）
```

## 继承

### 1、js实现继承的几种方式

```css
1.原型链继承：
通过将父类的实例赋值给子类的原型，实现继承。这样子类就可以访问父类的属性和方法。但是，子类的所有实例都会共享父类的属性和方法。

2.原型式继承（利用空对象继承）：
利用一个空对象作为中介，将父对象的原型赋值给子对象，实现继承。这样子对象可以访问父对象的属性和方法。

3.构造函数继承：
在子类的构造函数中调用父类的构造函数，使用call或apply方法将父类的属性和方法绑定到子类上。这样子类可以拥有独立的属性和方法，但无法访问父类原型上的方法。

4.组合继承：
也叫伪经典继承， 结合原型链继承和构造函数继承的方式。通过调用父类的构造函数绑定属性和方法，并将父类的实例赋值给子类的原型，实现继承。这样子类既可以拥有独立的属性和方法，又可以访问父类原型上的方法。
```

### 2、call和apply的区别

```css
它们的区别在于参数的传递方式：

call方法接受一个对象作为第一个参数，后面可以跟任意数量的参数，每个参数都会作为函数的参数传递进去。

apply方法也接受对象作为第一个参数，但是第二个参数是一个数组或类数组对象，数组中的每个元素都会作为函数的参数传递进去。

简而言之，call和apply的区别在于参数的传递方式，call是逐个传递参数，而apply是通过数组传递参数。
```

### 3、谈谈你对原型链的理解

```css
原型链是JavaScript中实现继承的一种机制。每个对象都有一个原型对象，通过原型链，对象可以访问其原型对象上的属性和方法。

原型链的顶端是Object.prototype，它是所有对象的基础原型。

可以通过构造函数来创建对象，构造函数可以定义对象的属性和方法，并且可以指定一个原型对象。通过构造函数创建的对象会继承构造函数的原型对象上的属性和方法，形成原型链。但需要注意的是，如果在原型链上的某个对象上修改了属性或方法，会影响到所有继承自该对象的子对象。
```

