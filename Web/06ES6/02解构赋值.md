## 变量的解构赋值

### 数组的解构赋值

#### 基本用法

ES6允许按照一定模式,从数组和对象中提取值,对变量进行赋值,这被称为解构(Desructuring),以前,为变量赋值,只能直接指定值

```js
let a=1;
let b=2;
let c=3;
```

在ES6允许写成下面这样

```js
let [a,b,c]=[1,2,3];
//数组解构赋值,就是等号左右两边按照位置对应关系(根据下标进行对应,从数组中提取质,对变量进行赋值的操作;本质上,这种写法属于"模式匹配",只要等号两边的模式相同,左边的变量就会被富裕对应的值
```

```js
    //按照下标的顺序依次赋值
    //   0  1  2     0  1  2
    let [a, b, c] = [1, 2, 3];
    console.log(a, b, c);//1 2 3

    let [a1] = [];
    console.log(a1);//undefined

    //等号右边没有对应的值赋值给左边时,等号左边的变量就为undefined
    let [a2, b2] = [1];
    console.log(a2, b2);//1 undefined

    //等号右边多余的值则丢弃
    let [a3, b3] = [1, 2, 3];
    console.log(a3, b3);//1 2

    //依然按照下标的顺序依次赋值,多余的值则丢弃
    let [a4, [b4], c4] = [1, [2, 3], 4];
    console.log(a4, b4, c4);//1 2 4

    //如果等号左边变量设置的有默认值也就是a5=1
    //当等号右边有对应的值时就是用等号右边的值
    //如果等号右边没有值并且为undefined时就使用等号左边的默认值
    let [a5 = 1] = [];
    console.log(a5);//1
```

如果解构不成功,变量的值就等于undefined

```js
let [foo]=[];
let [bar,foo]=[1];
console.log(foo);
```

不完全解构,即等号左边的模式,只匹配一部分的等号右边的数组;这种情况下,结构依然可以成功

```js
let [x,y]=[1,2,3];
console.log(x,y);//1,2

let [a,[b],c]=[1,[2,3],4];
console.log(a,b,c)//1,[2],4
```

如果等号的右边不是数组(或者严格来说,不是可遍历的结构),name将会报错

```js
//报错
let [foo]=1;
let [foo]=false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};

Interator接口,是一个遍历器对象,为各种不同的数据结构提供统一的访问机制
原生具备Iternator接口的数据结构如下
Array
Map
Set
String
TypedArray
函数的arguments对象
NodeList对象

let [bar,[foo]]=[1,2];
console.log(foo);
```

#### 默认值

+ 解构赋值允许指定默认值

+ ```js
  let [foo=true]=[];
  foo//true
  
  let [x,y='b']=['a'];//x='a',y='b'
  let [x,y='b']=['a',undefined];//x='a',y='b';
  let [x=y,y=1]=[];
  ```

```js
  
- 注意，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`（必须完全等于undefined，其他的情况默认值不生效），默认值才会生效。


  let [x = 1] = [undefined];
  x // 1
  
  let [x = 1] = [null];
  x // null
```

- 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

- ```js
  function f() {
    console.log('aaa');
  }
  
  let [x = f()] = [1];
  ```

### 三点运算符

```js
符号:..
根据用法,又可称之为
1、展开运算符
//把a数组中的数据,展开,放入到arr中,就可以使用...运算符
let a=[1,2,3,4,5,6];
let arr=['aa','bb','cc',...a]
console.log(arr);//['aa','bb','cc',1,2,3,4,5,6]

2、剩余运算符
//按照数组位置对应关系、进行赋值，把剩余的数据，大包艺术组形式，赋值给d
let [a,b,c,...d]=[1,2,3,4,5,6,7,8,9,10];
a//1
b//2
c//3
d//[4,5,6,7,8,9,10]
```

### 对象的解构赋值

#### 基本用法

解构不仅可以用于数组,还可以用于对象,对象的解构与数组有一个重要的不同;数组的元素是按照次序排列的,变量的取值由他们的位置决定的;而对象的属性没有次序,变量名必须与属性同名,才能取到正确的值

数组的解构赋值是按照位置对应关系赋值,对象的解构赋值是按照键值对的对应关系进行赋值

```js
   //数组的解构赋值
    let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
    let b = ['aa', 'bb', 'cc', 'dd', 'ee', ...a];
    console.log(b);
    let c = [...a]
    console.log(a);

    let [a1, b1, c1, ...d1] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
    console.log(a1, b1, c1, d1);


    console.log('--------------------------');
    //对象的解构赋值

    let obj = { name: myname, age: myage, sex: mysex, address: myaddress } = { name: '老李', age: '23', address: '河南周口' };
    console.log(myname);
    console.log(myage);
    console.log("obj", obj);

    let { log: log } = console;
    // log(console);

    const person = {
        name1: '小李',
        age1: '18',
    }

    const { name1, age1 } = person;
    console.log(name1);
    console.log(age1);


    //与数组一样,结构也可用于嵌套结构的对象
    const student = {
        name: '二狗',
        address: '河南 郑州',
        hoby: {
            music: ['爵士', '民谣', '摇滚'],
            game: ['王者荣耀', '穿越火线', '金铲铲之战']
        }
    }

    let { name, address, hoby, hoby: { music, game } } = student;
    console.log(name);
    console.log(address);
    console.log(hoby);
    console.log(music);
    console.log(game);


    // 字符串的解构赋值
    //类似数组的对象都有一个length属性,因此还可以对这个属性解构赋值
    const [a2, b2, c2, d2, e2] = 'hello';
    console.log(a2, b2, c2, d2, e2);//h e l l o



    //函数参数的解构赋值
    function add([x, y]) {
        return x + y;
    }

    console.log(add([1, 2]));//3


    // 函数的参数的解构赋值也可以使用默认值
    function add1([x, y = 20]) {
        return x + y;
    }

    console.log(add1([10]));//30


    function move({ x = 0, y = 0 } = {}) {
        return [x, y];
    }

    console.log(move({ x: 3, y: 8 }));//[3,8]
    console.log(move({ x: 3 }));//[3,0]
    console.log(move({ y: 8 }));//[0,8]
    console.log(move({}));//[0,0]
    console.log(move());//[0,0]





    // 变量解构赋值的用途
    //交换变量的值
    let a3 = 1;
    let b3 = 2;
    [a3, b3] = [b3, a3];
    console.log(a3, b3);//2,1


    // 从函数返回多个值
    //函数能返回一个值,如果要返回多个值,只能将他们放在数组或对象里返回,有了解构赋值,取出这些值就非常的方便
    // 返回一个数组
    function example() {
        return [1, 2, 3];
    }
    let [a4, b4, c4] = example();
    console.log(a4, b4, c4);//1 2 3

    function example1() {
        return {
            a5: 1,
            b5: 2,
        };
    }

    let { a5, b5 } = example1();
    console.log(a5, b5);//1 2


    //函数的定义
    //解构赋值可以方便的将一组参数与变量名对应起来
    // 参数是一组有次序的值
    function example2([x, y, z]) { }
    example2([1, 2, 3]);
    //参数是一组无次序的值
    function example3({ x1, y1, z1 }) { }
    example3({ z1: 3, x1: 3, y1: 3 })



    //提取JSON数据
    //解构赋值对提取JSON对象中的数据,尤其有用
    let jsonData = {
        id: 42,
        status: "ok",
        data: [867, 5309],
    };

    let { id, status, data } = jsonData;
    console.log(id, status, data);//42 'ok' [867,5309]
```



```js
let{name:myname,age:myage,sex:mysex}={name:'lisi',age:25};
myname//lisi
myage//25
mysex//undefined
```

对象的解构赋值,可以很方便的将现有对象的方法,赋值到某个变量

```js
let {log:log}=console;
//把console对象的方法log(控制台输出信息)	通过解构赋值给 log
console.log('xxx');等价于 log('xxx');
```

对象的解构赋值可以是下面形式的简写

```js
 let {foo:foo,bar:bar}={foo:'aaa',bar:'bbb'};

//对象解构赋值的时候 如果等号左边 属性和值一样 可以只写一个属性
let {foo,bar}={foo:'aaa',bar:'bbb'}
```

与数组一样,结构也可以用于嵌套结构的对象

```js
    //与数组一样,结构也可用于嵌套结构的对象
    const student = {
        name: '二狗',
        address: '河南 郑州',
        hoby: {
            music: ['爵士', '民谣', '摇滚'],
            game: ['王者荣耀', '穿越火线', '金铲铲之战']
        }
    }

    let { name, address, hoby, hoby: { music, game } } = student;
    console.log(name);
    console.log(address);
    console.log(hoby);
    console.log(music);
    console.log(game);
```

### 默认值

对象的解构也可以指定默认值,默认值生效的条件是，对象的属性值严格等于`undefined`。

```js
let {x,y=20} = {x:10}
x//10
y//20

var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
```

### 注意点

（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。

```javascript
// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error

//right
let {x} = {x:1}
({x} = { x: 1 });
```

上面代码的写法会报错，因为 JavaScript 引擎会将`{x}`理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。

```javascript
// 正确的写法
let x;
({x} = {x: 1});


let x;
....
....
....
({x} = obj);
```

上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。

（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。

```javascript
({} = [true, false]);
({} = 'abc');
({} = []);
```

上面的表达式虽然毫无意义，但是语法是合法的，可以执行。

（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。	

```javascript
let{0:a,1:b,2:c} = [1,2,3];
 console.log(a,b,c); //1,2,3
//等价于：  let{0:a,1:b,2:c} = {0:1,1:2,2:3};
```

上面代码对数组进行对象解构。数组`arr`的`0`键对应的值是`1`，`[arr.length - 1]`就是`2`键，对应的值是`3`。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。



## 字符串的解构赋值



字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。



```javascript
const [a, b, c, d, e] = 'hello';     'hello' == ['h','e','l','l','0']
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```

类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。

```javascript
let {length : len} = 'hello';
len // 5

//解析 'hello'
let hello = {
    length:5
}
let {length:len} = ’hello‘;
```





## 函数参数的解构赋值



函数的参数也可以使用解构赋值。



```javascript
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3

函数参数的解构也可以使用默认值。
function add([x, y=10]){
  return x + y;
}
add([1]); // 11

function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]

```

## 圆括号问题

解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。

由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。

但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。

```js
let {(x)} = {x:1}
```



## 用途

变量的解构赋值用途很多。

### **（1）交换变量的值**

```javascript
let x = 1;
let y = 2;

[x, y] = [y, x];
```

上面代码交换变量`x`和`y`的值，这样的写法不仅简洁，而且易读，语义非常清晰。

### **（2）从函数返回多个值**

函数能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。

```javascript
// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
```

### **（3）函数参数的定义**

解构赋值可以方便地将一组参数与变量名对应起来。

```javascript
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

### **（4）提取 JSON 数据**

解构赋值对提取 JSON 对象中的数据，尤其有用。

```javascript
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
```

上面代码可以快速提取 JSON 数据的值。

### **（5）函数参数的默认值**

```javascript
jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
```

指定参数的默认值，就避免了在函数体内部再写`var foo = config.foo || 'default foo';`这样的语句。

### **（6）遍历 Map 结构**

任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。

```javascript
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
```

如果只想获取键名，或者只想获取键值，可以写成下面这样。

```javascript
// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
```

### **（7）输入模块的指定方法**

加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。

```javascript
const { SourceMapConsumer, SourceNode } = require("source-map");
//加载进来的也是一个对象，本质，就是对象的解构赋值
```